<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/lylogo.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/lylogo16.png?v=5.1.4">






  <meta name="keywords" content="camiler blog">










<meta name="description" content="一枚患有严重选择综合症的前端学徒">
<meta property="og:type" content="website">
<meta property="og:title" content="camiler">
<meta property="og:url" content="http://camiler.github.io/index.html">
<meta property="og:site_name" content="camiler">
<meta property="og:description" content="一枚患有严重选择综合症的前端学徒">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="camiler">
<meta name="twitter:description" content="一枚患有严重选择综合症的前端学徒">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://camiler.github.io/">





  <title>camiler</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">camiler</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th-large"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2018/12/19/react-test/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/19/react-test/" itemprop="url">jest enzyme进行react项目测试实践小结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T19:52:28+08:00">
                2018-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index">
                    <span itemprop="name">FE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/19/react-test/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/12/19/react-test/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>“如果一个开源包没有一行测试代码，谁敢用？”      </p>
</blockquote>
<p>一直觉得页面代码无法进行代码测试，就算是代码测试也是内置了浏览器引擎，不然怎么模拟事件点击、网络请求。所以，要写出来，还不如自己在页面上点击来的方便直接。但凭这句话，我怎么样也要看看前端测试代码怎么写？有没有必要写？</p>
<p>搜罗了一堆关于react测试的文章，选择了jest结合enzyme来实践。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>install babel相关支持，enzyme react版本支持<br><code>npm install --save-dev babel-core@^7.0.0-bridge.0 @babel/core babel-jest enzyme enzyme-adapter-react-16 jest jest-cli react-test-renderer</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>项目中需要Babel进行编译，所以简单的jest默认配置无法正常运行，需要为jest设置一些特殊配置。<br>.jest.js文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  verbose: <span class="keyword">true</span>,</span><br><span class="line">  setupFiles: [<span class="string">'./test/setup.js'</span>],</span><br><span class="line">  testURL: <span class="string">'http://localhost:3000'</span>, <span class="comment">// 测试环境URL</span></span><br><span class="line">  moduleFileExtensions: [<span class="string">'js'</span>, <span class="string">'jsx'</span>], <span class="comment">// 单元测试文件检测后缀名</span></span><br><span class="line">  moduleDirectories: [<span class="string">"node_modules"</span>],</span><br><span class="line">  transformIgnorePatterns: [<span class="string">"/node_modules/"</span>],</span><br><span class="line">  coveragePathIgnorePatterns: [<span class="string">"/node_modules/"</span>],</span><br><span class="line">  modulePathIgnorePatterns: [<span class="string">"/node_modules/"</span>],</span><br><span class="line">  unmockedModulePathPatterns: [</span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/node_modules/react/"</span>,</span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/node_modules/react-dom/"</span></span><br><span class="line">  ],</span><br><span class="line">  collectCoverage: <span class="keyword">true</span>,</span><br><span class="line">  moduleNameMapper: &#123; <span class="comment">// mock模块</span></span><br><span class="line">    <span class="string">'\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$'</span>: <span class="string">'&lt;rootDir&gt;/test/__mocks__/fileMock.js'</span>,</span><br><span class="line">    <span class="string">'\\.(css|less)$'</span>: <span class="string">'identity-obj-proxy'</span>, <span class="comment">//告诉jest将webpack引用的css模拟导入，这样就可以按className原样去查找</span></span><br><span class="line">    <span class="string">'^@/(.*)$'</span>: <span class="string">'&lt;rootDir&gt;/src/$1'</span> <span class="comment">//webpack配置了 resolve alias: &#123;'@': path.resolve(__dirname, './src')&#125; 需要对应jest模块名称解析</span></span><br><span class="line">  &#125;,</span><br><span class="line">  transform: &#123;</span><br><span class="line">    <span class="string">"^.+\\.jsx?$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span>,</span><br><span class="line">    <span class="string">"^.+\\.js?$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span>,  <span class="comment">//安装babel-jest</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>.babelrc</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"modules"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"@babel/preset-react"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"development"</span>: &#123;</span><br><span class="line">      <span class="attr">"presets"</span>: [[<span class="string">"@babel/preset-react"</span>, &#123; <span class="attr">"development"</span>: <span class="literal">true</span> &#125;]],</span><br><span class="line">      <span class="attr">"plugins"</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"test"</span>: &#123;</span><br><span class="line">      <span class="attr">"presets"</span>: [[<span class="string">"@babel/preset-env"</span>], <span class="string">"@babel/preset-react"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    <span class="string">"react-hot-loader/babel"</span>,</span><br><span class="line">    <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-decorators"</span>, &#123; <span class="attr">"legacy"</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">    [<span class="string">"@babel/plugin-proposal-class-properties"</span>, &#123; <span class="attr">"loose"</span> : <span class="literal">true</span> &#125;],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"import"</span>, &#123;</span><br><span class="line">        <span class="attr">"libraryName"</span>: <span class="string">"antd"</span>, <span class="attr">"style"</span>: <span class="string">"css"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json scripts增加 <code>&quot;test&quot;: &quot;jest --config .jest.js&quot;</code></p>
<p>新建test文件夹，创建componentXX.test.js就可以开始编写测试用例了。</p>
<h2 id="如何编写？"><a href="#如何编写？" class="headerlink" title="如何编写？"></a>如何编写？</h2><h3 id="enzyme-v3-渲染API"><a href="#enzyme-v3-渲染API" class="headerlink" title="enzyme v3 渲染API"></a>enzyme v3 渲染API</h3><h4 id="shallow"><a href="#shallow" class="headerlink" title="shallow"></a><code>shallow</code></h4><p>浅层比较，state和props决定渲染结果。不会影响子组件，所以这类API通常用在最小单元组件或状态组件的测试，简单判断渲染结构、内部state是否和预想一致。可以随时<code>setProps</code>，<code>setState</code>, <code>setContext</code>改变数据。<br>v3版本中，shallow会调用react的<code>componentDidMount</code>和<code>componentDidUpdate</code>周期，所以可以模拟事件，查找节点，获取选择器进行结果的查询。</p>
<h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a><code>mount</code></h4><p>完整的DOM渲染，深层渲染。可以用于测试有DOM API的交互，或包裹在高阶组件中的组件，包含子组件的组件。完整的DOM渲染至少需要运行在一个像浏览器的环境中，如果不是浏览器环境，推荐使用<a href="https://github.com/tmpvar/jsdom" target="_blank" rel="noopener">jsdom</a>模拟。<br>与其他两个API不同的是，mount实际上会把组件挂载到DOM上，就是说mount中，如果用的是相同的DOM，它们会相互影响。必要时，使用<code>unmount()</code>清理。</p>
<h4 id="render"><a href="#render" class="headerlink" title="render"></a><code>render</code></h4><p>用于将react组件渲染为静态HTML，对HTML结构进行分析。使用<code>cheerio</code>解析HTML。所以一般不用该方法。有可能的用法之一是：检测react中通过<code>dangerouslySetInnerHTML</code>动态生成的HTML。</p>
<h3 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h3><p>惯用格式：it只是作为test的别名，两者一样。官方使用test。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe('des', () =&gt; &#123;</span><br><span class="line">  it('des', () =&gt; &#123;</span><br><span class="line">    expect().toEqual()<span class="comment">;</span></span><br><span class="line">  &#125;)<span class="comment">;</span></span><br><span class="line">  test('des', () =&gt; &#123;</span><br><span class="line">    expect().toBe()<span class="comment">;</span></span><br><span class="line">  &#125;)<span class="comment">;</span></span><br><span class="line">&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>另外jest提供了<a href="https://jestjs.io/docs/en/snapshot-testing" target="_blank" rel="noopener">UI渲染快照一致性测试</a>:<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> renderer <span class="keyword">from</span> <span class="string">'react-test-renderer'</span>;</span><br><span class="line"></span><br><span class="line">it(<span class="string">'renders correctly'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  const tree = renderer.create(&lt;Component /&gt;).toJSON();</span><br><span class="line">  expect(tree).toMatchSnapshot();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="如何写测试用例"><a href="#如何写测试用例" class="headerlink" title="如何写测试用例"></a>如何写测试用例</h3><p>测试最大的特点就是覆盖足够的逻辑点及边界。前端测试也是一样。   </p>
<p>针对react应用来说，内部state的变化是否按照预期那样在流转？react周期是不是在对的时间进行了调用，比如：props变化后，是否确实调用了<code>componentWillReceiveProps</code>了呢？当然周期的调用也可以通过state的流向侧面反应出来。模拟事件后，事件里的逻辑通过哪些现象可以得到印证？   </p>
<p>另外，我们知道，组件最终渲染结果是根据props和state决定的，所以如何确定相同的props，state确定得到了同一个DOM，而不同的props得到的DOM版本是不一样的？这些都可以通过enzyme的方法得到解决。</p>
<p>至于解决方法具体查看<a href="https://airbnb.io/enzyme/docs/api/" target="_blank" rel="noopener">enzyme api文档</a>，文档很简单，也有简单示例，先大致浏览一遍是干什么的，用时才有印象。</p>
<p>jest的断言方法也一样。另外jest提供了常用的<a href="https://jestjs.io/docs/en/mock-functions" target="_blank" rel="noopener">function</a>、<a href="https://jestjs.io/docs/en/es6-class-mocks" target="_blank" rel="noopener">es6 class</a>,  <a href="https://jestjs.io/docs/en/timer-mocks" target="_blank" rel="noopener">timer</a> mock功能，也可以<a href="https://jestjs.io/docs/en/manual-mocks" target="_blank" rel="noopener">人为mock</a>，通常用来mock数据。</p>
<h2 id="实践之后"><a href="#实践之后" class="headerlink" title="实践之后"></a>实践之后</h2><p>前期配置调试了很久，babel版本问题，import无法识别等等，前端配置越来越复杂，想如后端那样集构建测试一体确实不容易。前端真的要这样复杂么？毕竟本质来说就是运行在浏览器上的特定结构。当然这个问题答案肯定是既有好处也有坏处，我也总是徘徊不定。配置这些真的让人头疼，但框架的运用确实提高了效率。</p>
<p>回归正题，在编写测试代码时，我会问自己这个组件到底是做什么，要实现什么功能，会先梳理一遍内部逻辑才能开始想从哪里写。所以编写测试用例能够加深对代码的理解。测试代码运行后，会发现和预期不一致，再重新看组件逻辑，会发现有些地方处理有问题，而这个问题只不过业务没有覆盖到或者说没有用到，而作为组件需要提供这样一个选项。这些都是做测试的优势。对于基础组件，需要提供稳定一致的调用方法，完整的测试很有必要。</p>
<p>但初次写测试代码，尤其在项目已经完善后期，编写测试用例是个大工程。当然只要能完整的完成一个项目的所有测试用例，在业务模式一致，框架相同的条件下，后面的项目都可以套用了。尽管如此，在我静下来好好写下几个公共组件的test case之后…..写不下去了！可能是因为项目本身就基于antd，框架本身每个组件都有完整的测试，在这之上封装的组件也是基于业务逻辑，而测试业务逻辑还是交互页面感觉更轻松。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2018/10/11/redux-note/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/11/redux-note/" itemprop="url">redux理解-日常小记</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-11T19:52:28+08:00">
                2018-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index">
                    <span itemprop="name">FE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/11/redux-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/11/redux-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redux应用的好处"><a href="#redux应用的好处" class="headerlink" title="redux应用的好处"></a>redux应用的好处</h2><p>1、创造完全无状态组件<br>   除了UI基本组件用react内部的state，容器组件可以完全用store来存储进行状态变化，而无状态组件可以减少内部state和props之间的冲突，没有state了，完全由props决定，而props又来自一个store状态树，数据结构一目了然。<br>2、统一数据管理<br>   因为是SPA应用，store的数据只有在页面强制刷新后才会初始化，所以对于单页应用来说，统一数据管理可以减少数据请求、临时存储数据、尤其是移动端页面分步填写表单进行set store，即便在router变化后，之前的数据也能从store取到。</p>
<p>以上，数据和视图就很清晰了，会看到数据结构全在reducer里面，改变数据只需要进行不同的action进行触发设置state。MVVM，M是整个应用的数据模型，V是视图，VM就是store以及操作store的action和获取store的reducer了。</p>
<h2 id="坏处："><a href="#坏处：" class="headerlink" title="坏处："></a>坏处：</h2><p>1、很多模版代码<br>2、对于简单的react应用，内部state也够用，加redux增加了复杂度   </p>
<p>其实一直没get到好处，之前我会觉得用redux会写很多模版代码，也并没有深刻理解好在什么地方。最近一直在找替换单页应用中的toast、loading方案，感觉都没有用redux来做合适，再搜罗了一些博客，好像慢慢突然理解了。再回头看我现在的单页项目，好好组织下数据，是不是可以更清晰。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2018/07/20/react-api/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/20/react-api/" itemprop="url">React16.4常用API整理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-20T16:01:25+08:00">
                2018-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index">
                    <span itemprop="name">FE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/20/react-api/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/07/20/react-api/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>边看文档边整理下，确实通畅了很多。下图是目前最新React16.4版本的常用API：</p>
<p><img src="/img/reactjs16.4-API.png" width="100%"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2018/04/17/iterator-generator/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/iterator-generator/" itemprop="url">迭代器、生成器</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T17:27:09+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index">
                    <span itemprop="name">FE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/17/iterator-generator/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/17/iterator-generator/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="迭代协议"><a href="#迭代协议" class="headerlink" title="迭代协议"></a>迭代协议</h2><p>协议：可以被任何遵循某些约定的对象来实现。</p>
<h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p>允许JS对象去定义或定制它们的迭代行为。这个对象中必须实现@@iterator方法，即这个对象的属性（包括原型链上）必须有一个Symbol.iterator的属性。该属性返回一个对象的无参函数。</p>
<p>那么，也就是说通过 <code>typeof someObj[Symbol.iterator] === &#39;function&#39;</code>就可以判断这个对象是否可迭代。</p>
<p>JS中内置的可迭代对象有这些：String, Array, TypedArray(类数组), Map, Set。</p>
<h3 id="可迭代运用"><a href="#可迭代运用" class="headerlink" title="可迭代运用"></a>可迭代运用</h3><p>1、<code>for - of</code>: 可迭代对象都可以用for-of进行循环遍历<br>关于 <code>for-of</code> <code>for-in</code> <code>forEach</code>之间的区别可以参考下面这个栗子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'fasdfadsf'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);  <span class="comment">//读取键名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----分割线----'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 读取键值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----分割线----'</span>);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'b'</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// SyntaxError</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'b'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 没报错，但并没返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----分割线----'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 读取键值</span></span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'a'</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'b'</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 正常，显示到b就停止遍历了</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'c'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// SyntaxError</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、对可迭代对象的解构<br>3、扩展运算符（…）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="keyword">var</span> [first, ...rest] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(rest);  <span class="comment">// ['b', 'c', 'd']</span></span><br></pre></td></tr></table></figure></p>
<p>4、yield<em> ： yield</em>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> it = gen();</span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: true, value: undefined&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h3><p>定义了一种标准方式来产生一个有限或无限序列的值。迭代器上实现了一个next()方法，并且next()方法返回两个值：<br>1、done(boolean)：表示是否迭代完成。<br>2、value: 任何值，done为true时可省略。</p>
<p>下面是自定义一个对于对象的迭代器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myObjIterator</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Object]'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt; keys.length ? &#123;</span><br><span class="line">          value: obj[keys[idx++]], <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125; : &#123;</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"not object"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = myObjIterator(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: true&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>以上，我们可以自定义一个迭代器，有next方法就行，但是需要显示的维护内部状态，所以工作量也会无形中增多。而且并没有实现它的可迭代性，这就是一个Non-well-formed（(非-良好-格式化的）的可迭代对象。所以，生成器孕育而生。</p>
<h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h2><p>生成器允许你定义一个包含自有迭代算法的函数，还可以自动维护自己的状态。其语法就是<code>function*</code></p>
<p>生成器对象 既是迭代器也是可迭代对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aGeneratorObject = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> aGeneratorObject.next;  <span class="comment">// "function" 有next方法，是一个迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> aGeneratorObject[<span class="built_in">Symbol</span>.iterator];<span class="comment">// "function" 有Symbol.iterator属性，可迭代</span></span><br><span class="line"></span><br><span class="line">aGeneratorObject[<span class="built_in">Symbol</span>.iterator]() === aGeneratorObject; <span class="comment">// true  这是一个设计优良的可迭代对象</span></span><br><span class="line"></span><br><span class="line">[...aGeneratorObject]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>对于上面第一个实现对象迭代器的例子中，要实现它的可迭代性，可以像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="built_in">Object</span>.values(<span class="keyword">this</span>).sort();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> values) &#123;</span><br><span class="line">    <span class="keyword">yield</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(...obj); <span class="comment">// 1  2</span></span><br></pre></td></tr></table></figure>
<h3 id="Generator-语法说明"><a href="#Generator-语法说明" class="headerlink" title="Generator 语法说明"></a>Generator 语法说明</h3><p>1、调用一个Generator函数时，会返回一个内部指针对象，不会返回任何结果。<br>2、每一个yield或者return就是一个状态，通过next，将指针按顺序指向这些状态。<br>3、<code>yield</code> 作为一个表达式，本身没有返回值，但next方法可以带一个参数，这个参数会被当作上一个yield表达式的返回值</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2018/02/28/nodejsevent/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/28/nodejsevent/" itemprop="url">「翻译」Node.js 事件循环、计时器和process.nextTick()</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-28T09:59:55+08:00">
                2018-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index">
                    <span itemprop="name">FE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/02/28/nodejsevent/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/02/28/nodejsevent/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是事件循环？"><a href="#什么是事件循环？" class="headerlink" title="什么是事件循环？"></a>什么是事件循环？</h3><p>事件循环允许Node.js执行非阻塞I/O操作 - 尽管JavaScript是单线程的 - 只要可能就将操作卸载到系统内核。</p>
<p>由于大多数现代内核都是多线程的，他们可以在后台处理多个正在执行的操作。 当其中一个操作完成时，内核会通知Node.js，以便可以将相应的回调添加到轮询队列中得到最终执行。 我们将在本主题后面进一步详细解释这一点。</p>
<h3 id="事件循环解释"><a href="#事件循环解释" class="headerlink" title="事件循环解释"></a>事件循环解释</h3><p>当Node.js启动时，它就会初始事件循环，处理提供的输入脚本（或者进入REPL：Read-Eval-Print-Loop，本文不会提及。），这可能会导致异步API调用，调度定时器或调用<code>process.nextTick()</code>，然后开始处理事件循环。</p>
<p>下面的图表展示的是一个事件循环的操作顺序的简单概述：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │       <span class="built_in"> check </span>         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure></p>
<p>注意：每个方框将被称为事件循环的一个“阶段”。</p>
<p>每个阶段有一个要执行的先进先出的回调队列。虽然每个阶段都有其特定的方式，但通常情况下，当事件循环进入给定阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列耗尽或已执行回调的最大数量。当队列耗尽或达到回调限制时，事件循环将移至下一个阶段，依此类推。</p>
<p>由于这些操作中的任何一个都可以调度更多操作，并且在轮询阶段处理的新事件由内核排队，所以轮询事件可以在轮询事件正在处理时排队。 因此，长时间运行的回调可以使轮询阶段的运行时间远远超过计时器的阈值。 有关更多详细信息，请参阅定时器和轮询部分。</p>
<p><strong>注意</strong>：Windows和Unix/Linux实现之间略有差异，但对这里的表述不重要。 最重要的部分就在这里。 实际上有七八个步骤，但我们关心的那些 - Node.js实际使用的那些 - 就是上述这些。</p>
<h3 id="阶段概述"><a href="#阶段概述" class="headerlink" title="阶段概述"></a>阶段概述</h3><ul>
<li>timers: 这个阶段执行由<code>setTimeout()</code> 和 <code>setInterval()</code> 注册的回调。</li>
<li>I/O callbacks: 执行几乎所有的回调，除了关闭回调，由定时器注册的回调，和<code>setImmediate()</code></li>
<li>idle, prepare: 只是内部使用</li>
<li>poll: 检索新的I/O事件；在占用时节点将会阻塞在这里。</li>
<li>check: <code>setImmediate()</code>回调会在这里被调用。</li>
<li>close callbacks: 比如<code>socket.on(&#39;close&#39;, ...)</code>。</li>
</ul>
<p>在事件循环的每次运行之间，Node.js会检查它是否正在等待任何异步I/O或定时器，并在没有时清除关闭。</p>
<h3 id="阶段详解"><a href="#阶段详解" class="headerlink" title="阶段详解"></a>阶段详解</h3><h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>计时器规定了一个阈值，这个阈值是注册的回调才可能被执行的时间，而不是人们希望执行的确切时间。 定时器回调会尽可能早的在指定的时间过后执行; 但是，操作系统调度或其他回调的运行可能会延迟它们。</p>
<p><strong>注意</strong>：技术上来讲，当计时器被执行时，poll阶段会进行控制。</p>
<p>比如：假设你注册了一个延时是在100ms之后调用，然后，你的脚本开始是异步读取一个文件花了95ms:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  fs.readFile(<span class="string">'/path/to/file'</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></span><br><span class="line">someAsyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something that will take 10ms...</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当事件循环进入轮询阶段时，它有一个空队列（<code>fs.readFile()</code>尚未完成），因此它将等待剩余的毫秒数，直到计时器的阈值最早达到。 当等待了95ms后，<code>fs.readFile()</code>完成读取文件，并且需要10ms来完成添加回调到轮询队列并执行的操作。当回调完成时，队列中没有更多的回调了，所以事件循环会看到已经达到最快计时器的阈值，然后回到计时器阶段以执行计时器的回调。在这个例子中，你会看到被调度的定时器和它正在执行的回调之间的总延迟将是105ms。</p>
<p>注意：为防止轮询阶段时事件循环挨饿空闲，在停止轮询之前，为了执行更多的事件，libuv（实现Node.js事件循环和平台所有异步行为的C库）也有一个硬性最大值（取决于系统）。</p>
<h4 id="I-O-callbacks"><a href="#I-O-callbacks" class="headerlink" title="I/O callbacks"></a>I/O callbacks</h4><p>此阶段是执行某些系统操作（如TCP错误类型）注册的回调。例如，如果尝试连接时TCP套接字收到ECONNREFUSED，则某些*nix系统要等待报告该错误。这将排队在I/O回调阶段执行。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>在轮询阶段有两个主要功能：<br>    对阈值已到的定时器执行脚本，然后处理轮询队列中的事件。<br>当事件循环进入轮询阶段并且没有计时器时，会发生以下两件事之一：</p>
<ul>
<li>如果轮询队列不为空，则事件循环将遍历其回调队列，同步执行它们，直到队列耗尽或达到系统相关的强制限值。</li>
<li><p>如果轮询队列为空，则还发生以下两件事之一：</p>
<ul>
<li>如果脚本已通过<code>setImmediate()</code>进行了调度，则事件循环将结束轮询阶段并继续执行检查阶段以执行这些被调度的脚本。</li>
<li>如果脚本没有通过<code>setImmediate()</code>进行调度，则事件循环将等待将回调添加到队列中，然后立即执行它们。</li>
</ul>
</li>
</ul>
<p>一旦轮询队列为空，事件循环将检查已达到时间阈值的定时器。 如果一个或多个定时器准备就绪，则事件循环将回退到定时器阶段以执行这些定时器的回调。</p>
<h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>此阶段允许在轮询阶段结束后立即执行回调。 如果轮询阶段变得空闲并且脚本已经通过<code>setImmediate()</code>排队，则事件循环可能会继续检查阶段而不是等待。</p>
<p><code>setImmediate()</code>实际上是一个特殊的定时器，它在事件循环的一个单独的阶段中运行。它使用libuv API来调度回调，以在轮询阶段完成后执行。</p>
<p>通常，随着代码的执行，事件循环将最终进入轮询阶段，在那里它将等待传入的连接，请求等。但是，如果使用<code>setImmediate()</code>注册了回调并且轮询阶段变为空闲，事件循环将继续进行检查阶段，而不是等待轮询事件。</p>
<h4 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h4><p>如果套接字或句柄突然关闭（<code>例如socket.destroy()</code>），则在此阶段将触发’close’事件。 否则它将通过<code>process.nextTick()</code>触发。</p>
<h3 id="setImmediate-vs-setTimeout"><a href="#setImmediate-vs-setTimeout" class="headerlink" title="setImmediate() vs setTimeout()"></a><code>setImmediate()</code> vs <code>setTimeout()</code></h3><p><code>setImmediate</code> and <code>setTimeout()</code> 很相似，但其行为方式是不一样的，这取决于它们何时被调用。</p>
<p><code>setImmediate()</code>用于在当前轮询阶段完成后执行脚本。<br><code>setTimeout()</code>在经过最小阈值（以毫秒为单位）后调度脚本运行。<br>定时器执行的顺序取决于它们被调用的上下文。 如果两者都是在主模块内调用的，那么时序将受到进程性能的限制（可能会受到计算机上运行的其他应用程序的影响）。</p>
<p>例如，如果我们运行以下不在I/O周期内的脚本（即主模块），则两个定时器的执行顺序是非确定性的，因为它受过程执行的约束：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> timeout_vs_immediate.js</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">timeout_vs_immediate</span>.js</span><br><span class="line">timeout</span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">node</span> <span class="title">timeout_vs_immediate</span>.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>但是，如果在I/O周期内移动这两个调用，则立即回调总是首先执行：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> timeout_vs_immediate.js</span><br><span class="line">const fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">timeout_vs_immediate</span>.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br><span class="line"></span><br><span class="line"><span class="keyword">node</span> <span class="title">timeout_vs_immediate</span>.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>使用<code>setImmediate()</code>超过<code>setTimeout()</code>的主要优点是: 如果在I/O周期内进行调度，<code>setImmediate()</code>将始终在任何计时器之前被执行，不管当前有多少个计时器。</p>
<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><code>process.nextTick()</code></h3><h4 id="理解-process-nextTick"><a href="#理解-process-nextTick" class="headerlink" title="理解 process.nextTick()"></a>理解 process.nextTick()</h4><p>您可能已经注意到<code>process.nextTick()</code>没有显示在图中，即使它是异步API的一部分。 这是因为<code>process.nextTick()</code>在技术上并不是事件循环的一部分。 相反，nextTickQueue将在当前操作完成后处理，而不管事件循环处于当前哪个阶段。</p>
<p>回顾那张图，你在给定的阶段任何时候调用<code>process.nextTick()</code>，所有传递给<code>process.nextTick()</code>的回调都将在事件循环继续之前被解决。 这可能会造成一些不好的情况，因为它允许你通过递归调用<code>process.nextTick()</code>来“饿死”你的I/O，从而阻止事件循环到达轮询阶段。</p>
<h4 id="为什么可以这样"><a href="#为什么可以这样" class="headerlink" title="为什么可以这样?"></a>为什么可以这样?</h4><p>为什么像这样的东西被包含在Node.js中？ 其中一部分源于它的设计理念就是，即使不需要，API也应该始终是异步的。以此代码为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apiCall</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'string'</span>)</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback,</span><br><span class="line">                            <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'argument should be string'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码进行参数检查，如果不正确，它会将错误传递给回调函数。最近更新的API允许将参数传递给<code>process.nextTick()</code>，允许它将回调后传递的任何参数作为参数传播给回调函数，这样就不必嵌套函数了。</p>
<p>我们正在做的是将错误传递给用户，但只有在我们允许执行用户其余的代码之后。通过使用<code>process.nextTick()</code>，我们就能保证<code>apiCall()</code>总是在剩余代码之后且在允许事件循环继续之前运行其回调。为了达到这个目的，JS调用堆栈允许展开，然后立即执行提供的回调，这样就允许了开发者对<code>process.nextTick()</code>进行递归调用，而不会出现RangeError错误：超出v8的最大调用堆栈大小。</p>
<p>这种理念会造成一些潜在的困境。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个异步签名，但是调用了异步回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123; callback(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在someAsyncApiCall完成之前回调被调用了.</span></span><br><span class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一旦someAsyncApiCall完成, bar不会指向任何值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>用户定义<code>someAsyncApiCall()</code>具有异步签名，但它实际上是同步运行的。当它被调用时，提供给<code>someAsyncApiCall()</code>的回调将在事件循环的相同阶段被调用，因为<code>someAsyncApiCall()</code>实际上并不会异步执行任何操作。 因此，回调会尝试引用<code>bar</code>，即使它在作用域中可能没有该变量，因为该脚本无法运行到完成状态。</p>
<p>通过将回调放置在<code>process.nextTick()</code>中，脚本仍然具有运行到完成的能力，允许在调用回调之前对所有变量，函数等进行初始化。 它还具有不允许事件循环继续的优点。 在事件循环被允许继续之前，告知用户出错了可能是有用的。这是前一个使用<code>process.nextTick()</code>的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这里是个真实的例子:</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">server.<span class="literal">on</span>(<span class="string">'listening'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>当只有一个端口被传递时，该端口被立即绑定。 所以，’listening’回调可以立即被调用。 问题是<code>.on（&#39;listening&#39;）</code>回调不会在那个时候设置。</p>
<p>为了解决这个问题，’listening’事件在<code>nextTick()</code>中排队等待脚本运行完成。 这允许用户设置他们想要的任何事件处理程序。</p>
<h3 id="process-nextTick-vs-setImmediate"><a href="#process-nextTick-vs-setImmediate" class="headerlink" title="process.nextTick() vs setImmediate()"></a>process.nextTick() vs setImmediate()</h3><p>正如用户担心的，这里有两个方法很相似，但他们的名称有点让人困惑。</p>
<p><code>process.nextTick()</code>在同一阶段立即触发<br><code>setImmediate()</code>触发后面的迭代或者事件循环的“tick”<br>实质上，名称应该交换一下。 <code>process.nextTick()</code>比<code>setImmediate()</code>更快立即触发，但这是过去的人为因素，不太可能改变。修改这个转换会使npm上大部分包垮掉。 每天都有更多的新模块被添加，这意味着我们每多等一天，就会发生更多潜在损害。虽然他们很让人混淆，但名字本身不会改变。</p>
<p>我们建议开发者在所有情况都使用<code>setImmediate()</code>，因为这更容易理解。（而且使得代码在更多环境中兼容，比如浏览器JS中。）</p>
<h3 id="为什么使用-process-nextTick"><a href="#为什么使用-process-nextTick" class="headerlink" title="为什么使用 process.nextTick()?"></a>为什么使用 process.nextTick()?</h3><p>有两个主要原因：</p>
<p>1、允许用户处理错误，清理任何不需要的资源，或者可能在事件循环继续之前再次尝试请求</p>
<p>2、有时需要在调用堆栈解除之后但事件循环继续之前允许回调运行。</p>
<p>下面这个简单的例子就符合用户期望：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer();</span><br><span class="line">server.<span class="literal">on</span>(<span class="string">'connection'</span>, <span class="function"><span class="params">(conn)</span> =&gt;</span> &#123; &#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line">server.<span class="literal">on</span>(<span class="string">'listening'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; &#125;);</span><br></pre></td></tr></table></figure></p>
<p>假设<code>listen()</code>在事件循环的开始处运行，但监听<code>listening</code>的回调放置在<code>setImmediate()</code>中。 除非传递主机名，否则绑定到端口将立即发生。要继续进行事件循环，它必须进入轮询阶段，这意味着收到连接并非不可能，从而允许在监听事件之前触发连接事件。</p>
<p>另一个例子就是运行一个函数的构造器，假设该构造函数继承于<code>EventEmitter</code>，并且在构造函数中想调用一个事件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'event'</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你不能从构造函数中立即触发事件，因为脚本不会处理到用户为该事件指定回调的位置。 因此，在构造函数本身中，可以使用<code>process.nextTick()</code>来设置回调，以在构造函数完成后触发事件，从而提供预期的结果：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use nextTick to emit the event once a handler is assigned</span></span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'event'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">查看原文</a></p>
<h3 id="译者补充"><a href="#译者补充" class="headerlink" title="译者补充"></a>译者补充</h3><p>1、node的核心思想就是异步，异步的实现是基于一个C库–libuv，这个库其实是又一层封装，针对windows和*nix两种系统进行了不同的处理。<br>2、Node的I/O异步<br>    I/O操作主要包括http请求，文件读取等。下图就是整个异步I/O流程：</p>
<p><img src="/img/IOchart.png" alt="io-chart"></p>
<p>这里有三个概念：请求对象，IO观察者，IOCP，线程池。IOCP，是Windows的内核对象，*nix是通过其他方法模拟实现。以下摘自<a href="https://zh.wikipedia.org/wiki/IOCP" target="_blank" rel="noopener">wikipedia</a>:</p>
<blockquote>
<p>输入输出完成端口（Input/Output Completion Port，IOCP）, 是支持多个同时发生的异步I/O操作的应用程序编程接口。</p>
<p>原理：通常的办法是，线程池中的工作线程的数量与CPU内核数量相同，以此来最小化线程切换代价。一个IOCP对象，在操作系统中可关联着多个Socket和（或）文件控制端。 IOCP对象内部有一个先进先出（FIFO）队列，用于存放IOCP所关联的输入输出端的服务请求完成消息。请求输入输出服务的进程不接收IO服务完成通知，而是检查IOCP的消息队列以确定IO请求的状态。 （线程池中的）多个线程负责从IOCP消息队列中取走完成通知并执行数据处理；如果队列中没有消息，那么线程阻塞挂起在该队列。这些现成从而实现了负载均衡。</p>
</blockquote>
<p>3、Node的非I/O异步<br>非I/O的异步操作包括：<code>setTimeout()</code>, <code>setInterval()</code>, <code>process.nextTick()</code>, <code>setImmediate()</code>。</p>
<p>以setTimeout()行为为例：</p>
<p><img src="/img/setTimeout.png" alt="settimeout"></p>
<p>结合译文中那张时间循环阶段图，I/O的异步是在I/O callbacks阶段，<code>setTimeout()</code>和<code>setInterval()</code>是在timer阶段，事件循环中每一次循环会经过那几个阶段，在I/O callbacks阶段中主要是I/O观察者接收通知获取其回调函数及请求结果，然后在此阶段执行回调函数。timer阶段主要是检查由定时器放入的handles是否到达时间，从而执行回调。</p>
<p>对于<code>process.nextTick()</code>和<code>setImmediate()</code>， 前者是idle观察者，后者是check观察者，在每一次循环中，idle观察者先于I/O观察者，I/O观察者先于check观察者。同时，<code>process.nextTick()</code>的回调保存在一个数组中，每次循环会将数组中的回调全部执行完，而<code>setImmediate()</code>的回调保存在链表中，每次循环只执行链表中的一个回调节点。</p>
<p>执行顺序实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</span><br><span class="line">  fs.readFile(<span class="string">'/koa.js'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - startCallback&#125;</span>ms readfile`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next tick1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next tick2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">someAsyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'next tick'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">next</span> tick1</span><br><span class="line"><span class="keyword">next</span> tick2</span><br><span class="line"><span class="number">2</span>ms <span class="built_in">readfile</span></span><br><span class="line">setImmediate</span><br><span class="line"><span class="keyword">next</span> tick</span><br><span class="line"><span class="number">103</span>ms have passed since I was scheduled</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2018/01/31/ten-years/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/31/ten-years/" itemprop="url">我的十年</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-31T19:30:25+08:00">
                2018-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/life/" itemprop="url" rel="index">
                    <span itemprop="name">life</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/31/ten-years/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/01/31/ten-years/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>十年前，读高二，那年汶川大地震还有北京奥运会。    </p>
<p>摇晃的地板，天花板上散落的粉尘，我跌跌撞撞地从二楼跑到一楼，跑到空地，呆呆的看着冒烟的教学楼不知道发生了什么，以为是一楼做化学实验发生了爆炸。听到人说是地震，总是后知后觉的我才惊醒过来原来地震是这样。<br>随后，大家的摩托罗拉，诺基亚都纷纷表示没有信号了。     </p>
<p>那天晚上，所有的同学老师在操场睡(坐)(站)了一夜。   </p>
<p>第二天通知放假一个月。   </p>
<p>回到家，家里那个厚重的电视机放在了地上，怕再地震摔了。好几千块的数字电视是父母拮据攒了好久才买下来的。想到家，想到父母的十年，总觉辛酸。那时候的日子，现在想想父母该是怎样熬过来的。家，这个字，太沉重，太温馨，太多回忆。还是收住吧。    </p>
<p>那时候的我，有两位很交心的朋友。每天谈论的是考题，一点八卦，相互鼓励，相互学习，一起在中午十二点钟响冲向食堂，而我们基本上也是最早一批到食堂的。因为我们班在二楼并且离电梯最近，一楼都是实验室。晚上一起打水，从学校这头穿过长长的过道还有地下通道，走到马路对面的女生宿舍。    </p>
<p>晚上关灯后喜欢听我哥送我那个魅族的MP3，到现在都觉得那个MP3挺好看的，貌似还有看视频的功能。庆幸，现在魅族还活着。对于我哥，也有太多的满满温馨美好又辛酸的事情，也很难轻易写出来。    </p>
<p>那时候才刚接触电脑，第一堂电脑课都不知道怎么开机。后面都不记得用什么语言写了个加法乘法函数。那时候网吧好火，就跟同学去了一次，花了两块钱，呆了一个小时，貌似就只干了一件事：注册了个QQ号，好像还看了点东方神起的视频。</p>
<p>10年后，已是工作近四年的人了。这年，等待着是不是也会发生什么不同寻常的事。    </p>
<p>圈子里的人用的手机不是iphone就是iphone还是iphone，当然我是安卓档。而当初那个总是对电脑畏手畏脚的女孩，现在竟然是一名前端程序媛。我做的工作竟也是我十年前完全没有想到的。人生总是处处出乎意料。    </p>
<p>那时候很要好的两个朋友也没什么联系，只是偶尔看到朋友圈的状态和微博。那时候的圈子就是高中，现在的圈子是互联网公司。感觉整个世界的人都被划分到了各种各样的圈子，你的一生会走进几个不同的圈子，每到一个圈子就会遇到一些人一些事，或许只有一两个人能和你成为朋友，其他人对你而言只是过客，而你对他们而言亦是如此。于是，我们在不同的轨迹上走着，或许相交，或许重叠一段，而自始自终都没有任何一个人可以和你一起走。    </p>
<p>现在的我，竟也是一个已婚妇女了。开始体会有家的感觉，过几年，或许就会开始体会身为人母的感觉。    </p>
<p>或许这十年是我最好的十年，不过，我还是期待下个十年，相信下个十年会是更好的十年。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2018/01/19/koa/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/19/koa/" itemprop="url">Koa2</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-19T17:27:09+08:00">
                2018-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index">
                    <span itemprop="name">FE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/19/koa/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/01/19/koa/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Koa是由Express的原班人马打造的新一代web框架，针对web应用和APIs，旨在成为一个更小，更生动，更强壮的基础框架。借助生成器，Koa可以让你不再受回调的困扰，还大幅度提高了错误处理能力。同时，核心不会集成任何中间件，提供了一套更优雅的方法，使我们写服务端代码更快速更加享受。 </p>
<h2 id="Koa2-Vs-Express"><a href="#Koa2-Vs-Express" class="headerlink" title="Koa2 Vs Express"></a>Koa2 Vs Express</h2><h3 id="设计哲学上的不同"><a href="#设计哲学上的不同" class="headerlink" title="设计哲学上的不同"></a>设计哲学上的不同</h3><p>1、Koa: 为了解决并替换node，Express：增强了node<br>2、Koa使用promise和async来避免回调地狱，使错误处理简单化。暴露它本身的<code>ctx.request</code>和<code>ctx.response</code>对象，而非node的<code>req</code>和<code>res</code>对象。 Express增强了node的<code>req</code>和<code>res</code>对象，添加额外的属性和方法，一级包含了一些其他的”框架”特征，比如路由和模板。但Koa没有这样做。<br>3、Koa可以被视为是node<code>http</code>模块的抽象，但Express是一个针对node的完整的应用框架。</p>
<table>
<thead>
<tr>
<th style="text-align:right">Feature</th>
<th style="text-align:center">Koa</th>
<th style="text-align:center">Express</th>
<th style="text-align:center">Connect</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Middleware Kernel</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:right">Routing</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">Templating</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">Sending Files</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">JSONP</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="Express原理浅析"><a href="#Express原理浅析" class="headerlink" title="Express原理浅析"></a>Express原理浅析</h3><p>我们先只用node的http模块启动一个服务，监听3000端口，以及几个路由：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = require(<span class="string">'http'</span>);</span><br><span class="line">http.createServer((req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">if</span> (req.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/html"</span> &#125;);</span><br><span class="line">    res.<span class="built_in">end</span>(<span class="string">"Welcome to the homepage!"</span>);</span><br><span class="line">  &#125; <span class="built_in">else</span> <span class="built_in">if</span> (req.url == <span class="string">"/about"</span>) &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/html"</span> &#125;);</span><br><span class="line">    res.<span class="built_in">end</span>(<span class="string">"Welcome to the about page!"</span>);</span><br><span class="line">  &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">    res.<span class="built_in">end</span>(<span class="string">"404 error! File not found."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="built_in">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码的意思是我们启动了一个3000端口的服务，并注册了回调函数，回调函数接收req, res, next三个返回值。当在浏览器输入localhost:3000后，回调函数才会执行。   </p>
<p>用express之后，createServer中入参回调函数就换成了下面一个express的app实例：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">app</span> = express();</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">set</span>('views', path.join(__dirname, 'views'));</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">set</span>('<span class="keyword">view</span> engine', 'hbs');</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>(cookieParser());</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>('/api', checkLoginStatus, apiRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pageRouter = express.Router();</span><br><span class="line">pageRouter.<span class="built_in">get</span>('/page', (req, res, next) =&gt; &#123;res.rendder('page', page)&#125;);</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>('/page', pageRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理没有URL匹配的中间件</span></span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>((req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">//不处理 map 和 json 格式的数据</span></span><br><span class="line">  <span class="keyword">if</span> (/\.(map|json)$/.<span class="keyword">test</span>(req.url)) &#123;</span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">err</span> = new <span class="keyword">Error</span>(`<span class="variable">$&#123;req</span>.url&#125;,Not Found`);</span><br><span class="line">  <span class="keyword">err</span>.status = 404;</span><br><span class="line">  next(<span class="keyword">err</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有错误处理，这里就是最后一个中间件处理了</span></span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>((<span class="keyword">err</span>, req, res, next) =&gt; &#123;</span><br><span class="line">  res.status(<span class="keyword">err</span>.status || 500);</span><br><span class="line">  res.render('<span class="keyword">error</span>', &#123;</span><br><span class="line">    layout: false,</span><br><span class="line">    title: '<span class="keyword">Error</span>',</span><br><span class="line">    message: <span class="keyword">err</span>.message,</span><br><span class="line">    <span class="keyword">error</span>: <span class="keyword">err</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="keyword">app</span>).listen(3000);</span><br></pre></td></tr></table></figure>
<p>app使用每一层中间件来处理请求，可以看到通过app.use的方式处理的是应用级别的，比如开始的一些模板cookie等的设置，应用的访问结构（一级访问路径），最后的容错处理等。每一层中间件可以是路由级别的中间件，也可以是个过滤器，拦截器等等。每个请求都会从上到下走一遍，有的中间件是检查权限，有的根据它再获取一些新东西再加到它身上，可能有的让它next()，继续去下一个中间件，有的一拍即合就直接res.render或者res.json，那么这个请求就完成了它的使命，不会再继续往下走了。   </p>
<p>按照使用方法，我们逐条对着源码看看express做了什么。   </p>
<p>首先是<code>var app = express()</code> 这句声明。</p>
<p><strong>主入口express.js</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">require</span>(<span class="string">'./application'</span>);</span><br><span class="line"><span class="keyword">var</span> req = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line">exports = <span class="built_in">module</span>.exports = createApplication;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义 app 字面量函数</span></span><br><span class="line">  <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    app.handle(req, res, next);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// defines EventEmitter.prototype's descriptors on app if app does not have a descriptor by the same name</span></span><br><span class="line">  mixin(app, EventEmitter.prototype, <span class="literal">false</span>);</span><br><span class="line">  mixin(app, proto, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// expose the prototype that will get set on requests</span></span><br><span class="line">  app.request = <span class="built_in">Object</span>.create(req, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose the prototype that will get set on responses</span></span><br><span class="line">  app.response = <span class="built_in">Object</span>.create(res, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(app.response.app.response === app.response); </span><br><span class="line">  app.init();</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>var app = express()</code>这句调用得到的app就是<code>createApplication</code>方法中返回的app。app是个函数，并将node的req, res, next传给了app内部handle方法，赋予handle对于内部对象的控制权。注意这里只是注册handle处理函数，并没有执行。<br>关于以上有一个疑问：<code>app.response</code>和<code>app.request</code>的原型上要暴露app？而app.response.app.response === app.response 执行结果也是true。<br>可以看到，这里app对象里面也暴露了node events模块的方法，除此之外，在这个主文件中还暴露了封装的Route，Router，还有以下几个中间件：   </p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exports</span>.json = bodyParser.json</span><br><span class="line"><span class="keyword">exports</span>.query = require(<span class="string">'./middleware/query'</span>);</span><br><span class="line"><span class="keyword">exports</span>.<span class="keyword">static</span> = require(<span class="string">'serve-static'</span>);</span><br><span class="line"><span class="keyword">exports</span>.urlencoded = bodyParser.urlencoded</span><br></pre></td></tr></table></figure>
<p>然后主入口里面还有这句函数调用：<code>app.init()</code>, 在init中设置了一系列私有变量以及配置项。毕竟在正式开始前，都需要配置一些默认参数。 至此，主入口文件大致搞清楚了。</p>
<p>接下来我们看看启动服务监听端口的声明：<code>app.listen(3000)</code></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.listen = function listen() &#123;</span><br><span class="line">  var<span class="built_in"> server </span>= http.createServer(this);</span><br><span class="line">  return server.listen.apply(server, arguments);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里其实就是执行了<code>http.createServer(app).listen(3000)</code>。</p>
<p><strong>app.use</strong></p>
<p>重点来了，源码中有大部分是对参数的处理，从最上面的使用代码也可以看到app.use的参数形式多样，总得需要一些判断校验处理，所以省略这些，贴出源码中真正处理的部分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里还有一些处理</span></span><br><span class="line">  <span class="comment">// fns得到所有调用app.use中的函数数组</span></span><br><span class="line">  <span class="keyword">var</span> fns = flatten(slice.call(<span class="built_in">arguments</span>, offset));</span><br><span class="line">  <span class="comment">// setup router</span></span><br><span class="line">  <span class="keyword">this</span>.lazyrouter();</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;</span><br><span class="line"></span><br><span class="line">  fns.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// non-express app</span></span><br><span class="line">    <span class="keyword">if</span> (!fn || !fn.handle || !fn.set) &#123;</span><br><span class="line">      <span class="keyword">return</span> router.use(path, fn);</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="comment">// 这里处理：如果fn本身有handle或set方法，app就会恢复到出厂设置。</span></span><br><span class="line">	 <span class="comment">// 基本上就是执行app.use(express());才会走到这里</span></span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以<code>app.use(&#39;/&#39;, (req, res) =&gt; {res.send(&#39;hello world&#39;)})</code>调用为例，最终就是执行:<br><code>router.use(&#39;/&#39;, (req, res) =&gt; {res.send(&#39;hello world&#39;)})</code></p>
<p><strong>router.use</strong></p>
<p>同样省去那些校验判断取核心：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, &#123;</span><br><span class="line">  sensitive: <span class="keyword">this</span>.caseSensitive,</span><br><span class="line">  strict: <span class="literal">false</span>,</span><br><span class="line">  end: <span class="literal">false</span></span><br><span class="line">&#125;, fn);</span><br><span class="line"></span><br><span class="line">layer.route = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.stack.push(layer);</span><br></pre></td></tr></table></figure>
<p>调用router.use就会new一个Layer，这个Layer就是一个类，声明如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layer</span><span class="params">(path, options, fn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Layer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Layer(path, options, fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.handle = fn;</span><br><span class="line">  <span class="comment">// 还有一些属性设置  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子带入之后就是Layer.handle = pageRouter; 这样每一次app.use都会通过这样创建一个层，可以看做是 express 在启动运行的时候，注册好了一个中间件函数栈stack，里面堆叠好了待被调用的中间层，<strong>一旦请求进来，就会执行回调函数，即正式调用app, 也就是<code>app()</code>, app.handle开始执行：</strong></p>
<p><strong>app.handle</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.handle = function handle(req, res, callback) &#123;</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;</span><br><span class="line">  <span class="comment">// final handler</span></span><br><span class="line">  <span class="keyword">var</span> done = callback || finalhandler(req, res, &#123;</span><br><span class="line">    env: <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'env'</span>),</span><br><span class="line">    onerror: logerror.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  router.handle(req, res, done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>app.handle又把node服务回调里的三个参数，继续分派给了 express 的核心路由模块。</p>
<p><strong>router.handle</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">proto.handle = <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(req, res, out)</span></span> &#123;</span><br><span class="line">  <span class="built_in">next</span>();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err)</span></span> &#123;</span><br><span class="line">    var layer;</span><br><span class="line">    var route;</span><br><span class="line">    // process_params是处理中间层参数的方法</span><br><span class="line">    self.process_params(layer, paramcalled, req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (route) &#123;</span><br><span class="line">        <span class="keyword">return</span> layer.handle_request(req, res, <span class="built_in">next</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      trim_prefix(layer, layerError, layerPath, <span class="built_in">path</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">trim_prefix</span><span class="params">(layer, layerError, layerPath, path)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (layerError) &#123;</span><br><span class="line">      layer.handle_error(layerError, req, res, <span class="built_in">next</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      layer.handle_request(req, res, <span class="built_in">next</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>按照helloworld的例子，以上最终走向layer.handle_request(req, res, next)。</p>
<p><strong>layer.handle_request</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Layer.prototype.handle_request = <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(req, res, next)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">this</span>.handle;  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *this.handle就是(req, res) =&gt; &#123;res.send('hello world')&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (fn.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// not a standard request handler</span></span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(req, res, next); <span class="comment">//执行了res.send('hello world')</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    next(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>似乎过程通了，当事件触发时，在express启动时注册的回调函数开始一层一层过滤执行。有点不太清楚为什么要这样通过app.handle =&gt; router.handle =&gt; layer.handle注册回调函数，或许express目的就是做一个完整的应用框架，需要更多的扩展，需要应用级别的层次感，更多的属性以应对各种各样的web应用请求。毕竟大牛们的脑回路是普通人没法比的。如果没有express，我们的node服务估计就是一大串的<code>switch-case</code> 或者<code>if-else</code>，无法想象了！   </p>
<h3 id="Koa2"><a href="#Koa2" class="headerlink" title="Koa2"></a>Koa2</h3><p>先看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> indent = <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).join(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">`&lt;h3&gt;请求 =&gt; 第一层中间件&lt;/h3&gt;`</span></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  ctx.body += <span class="string">`&lt;h3&gt;响应 &lt;= 第一层中间件&lt;/h3&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body += <span class="string">`&lt;h3&gt;<span class="subst">$&#123;indent(<span class="number">4</span>)&#125;</span>请求 =&gt; 第二层中间件&lt;/h3&gt;`</span></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  ctx.body += <span class="string">`&lt;h3&gt;<span class="subst">$&#123;indent(<span class="number">4</span>)&#125;</span>响应 &lt;= 第二层中间件&lt;/h3&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body += <span class="string">`&lt;p style="color: #f60"&gt;<span class="subst">$&#123;indent(<span class="number">12</span>)&#125;</span>=&gt; Koa 核心 处理业务 &lt;=&lt;/p&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>和Express一样，new一个Koa的实例app,中间件也是通过app.use传递，也是通过app.listen(3000)启动服务监听3000端口，但和Express不同的是，app.listen的实现是这样：<br><code>http.createServer(app.callback()).listen(3000)</code><br>Koa传入的是实例的callback方法，而express传入的是app本身。</p>
<p><strong>app.use</strong></p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span>(<span class="function"><span class="keyword">fn</span>) &#123;</span></span><br><span class="line"><span class="function">  this.middleware.<span class="keyword">push</span><span class="params">(<span class="keyword">fn</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Koa的use很简单，就是把进来的函数压入到一个数组中。再看app.callback()做了什么：</p>
<p><strong>app.callback</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);	</span><br><span class="line">  <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	 <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">	 <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是compose方法，简单说来就是把那些通过app.use设置的中间件组装成一个递归函数，递归的是Promise方法，而在中间件数组中都是async函数，async本身就是返回Promise，用递归的方式实现Promise的链式执行。    </p>
<p>然后，执行callback()，callback返回了一个local作用域方法handleRequest。这个方法里面通过类方法<code>createContext</code>将req, res合成了ctx，我们会用到的全部属性都在ctx里面，然后将ctx和递归函数fn丢给内部方法<code>this.handleRequest</code>。当我们访问服务时，local的handleRequest(req, res)就触发执行了，并且返回的是<code>this.handleRequest</code>执行后的返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">  <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">  <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候compose后的链式Promise函数开始执行。到这里，反正我脑子已经不够用了。很抽象，每一行源码都涉及到很深的基础知识，还有对新特性的深入理解。基础不扎实，而且设计又很抽象，确实看起来比较费力。最后放上两张<a href="https://juejin.im/post/5a6dda1d5188257330612d88?utm_source=gold_browser_extension#heading-2" target="_blank" rel="noopener">参考文章-Koa2 还有多久取代 Express</a>里的两张图：    </p>
<p>中间件执行顺序：<br><img src="/img/koa.gif" alt="koa"></p>
<p>请求处理洋葱圈模型：<br><img src="/img/koause.png" alt="koa-use"></p>
<p>后面用起来慢慢体会吧！看Koa2的源码，最大的感受就是Koa2充分运用新的语言特性，自身代码更简洁。整个框架就是4个js文件，结合注释都不到1K行。正如参考文章作者说的，这都是历史的必然。   </p>
<p>对于为什么服务会这样运行，比如，createServer中我们注册的回调函数为什么会在访问浏览器时才触发？这里面需要结合node的事件机制来理解了。我了解不多，<a href="https://juejin.im/post/5a6dda1d5188257330612d88?utm_source=gold_browser_extension#heading-2" target="_blank" rel="noopener">参考文章-Koa2 还有多久取代 Express</a>也有提到，很多还不太理解。到能理解的时候，再做些记录。</p>
<p><strong>TODO：</strong><br>1、搭建Koa2工程化服务<br>2、理解NodeJS事件机制</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2018/01/01/how-js-works/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/01/how-js-works/" itemprop="url">JavaScript是如何工作的</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-01T11:28:23+08:00">
                2018-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index">
                    <span itemprop="name">FE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/01/01/how-js-works/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/01/01/how-js-works/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看<a href="https://blog.sessionstack.com/tagged/tutorial" target="_blank" rel="noopener">HOW JAVASCRIPT WORKS</a>一系列文章，做些摘要笔记。</p>
<h2 id="引擎、运行时、调用栈"><a href="#引擎、运行时、调用栈" class="headerlink" title="引擎、运行时、调用栈"></a>引擎、运行时、调用栈</h2><p>广为人知的JS引擎当属V8了，其中主要包含了两个部分：</p>
<ul>
<li>内存堆-内存分配</li>
<li>调用栈-代码执行时的位置即所在的栈帧</li>
</ul>
<p>在下图中，框以内的就是引擎包含的内容，框以外的是浏览器提供的遵循ES标准的Web API、事件轮询、回调队列。我相信很多同学可能跟我一样，开始学习JS时会觉得DOM操作，回调队列什么的都是引擎实现的。现在仔细想想，ES标准为什么会存在浏览器差异，这就是原因了吧。   </p>
<p><img src="http://p0.qhimg.com/t01a740c0b9b73dbfd6.png"></p>
<p>JS是单线程语言，换句话说就是它只有一个调用栈。调用栈就是一种记录程序执行处于哪个位置的数据结构。栈是一种先进后出、后进先出的数据结构。<br>看这样一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>JS<strong>运行</strong>顺序：<br><code>printSquare(5) =&gt; multiply(x, y) =&gt; console.log(s)</code><br>调用栈：<br><img src="https://cdn-images-1.medium.com/max/1600/1*Yp1KOt_UJ47HChmS9y7KXw.png"><br>这样是不是很直观易懂了！</p>
<p>我们常常会碰到这样的错误：<br><img src="https://cdn-images-1.medium.com/max/1600/1*e0nEd59RPKz9coyY8FX-uw.png"><br>栈溢出了！一般说来通常发生在循环调用的情况，比如以下一段代码：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    foo();</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>所以在使用递归时，正确的条件终止就很重要了～    </p>
<h2 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h2><p>V8引擎之所以这么流行，有个重要原因是Node.js也是基于V8。    </p>
<p>V8设计之初就是为了提高JS在浏览器中的执行速度，所以V8直接将JS代码转换成更有效率的机器代码而非使用解释器的方式。V8实现了一个名为JIT(Just-In-Time)的编译器，它将JS代码编译成机器代码。而且这里区别于其他引擎最主要的一点是：V8不生成字节码或任何中间代码，这样就无需解释器。  </p>
<p>引擎中有几个线程分工协作，分别完成加载代码执行、编辑优化、垃圾回收、记录执行时间等。对于它是如何具体优化编译可以具体查看<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">原文</a>。几个主要概念记录如下：   </p>
<ul>
<li>内联：就跟webpack打包把import的具体一段样式代码插到import的位置类似，通过内联的方式，将调用的函数替换到调用位置。</li>
<li>隐藏类：具体例子在原文中可以看到。隐藏类是在运行时创建，用来查找对象位置。我的理解是，代码执行时，依照执行顺序，每执行一句，就创建一个隐藏类，这个隐藏类又基于前一句代码执行时创建的隐藏类。这样，<strong>代码的执行顺序也会对隐藏类顺序产生影响</strong>。而且它会不断叠加记录上一个隐藏类的offset。所以当一个对象执行完后，到最后那个隐藏类上就记录了之前每一句代码的隐藏类offset。</li>
<li>内联缓存：对于重复的调用内联代码，那么这段调用也会有相同的隐藏类。V8先查找该对象的隐藏类，确定offset，在对同一个隐藏类进行了两次成功的调用后，V8就会省去隐藏类查找，只将offset添加到该对象指针本身上就行了。这样，对于对该方法的重复调用，V8会直接通过offset跳转到对应的内存地址。</li>
</ul>
<p>对于隐藏类，也不确定理解是否正确。补充原文中的图文加强一下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*spJ8v7GWivxZZzTAzqVPtA.png"><br>所以，针对以上，在写代码时，就有下面几点可以注意了：<br>1、对象属性的顺序：始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。<br>2、动态属性：在实例化后向对象添加属性会强制修改隐藏类，减慢为之前的隐藏类优化了的方法。所以应该在构造函数中指定对象的所有属性。<br>3、方法：重复执行相同方法的代码将比只执行一次的代码（由于内联缓存）运行得快。<br>4、数组：避免键不是增量数字的稀疏数组。元素不全的稀疏数组是一个哈希表，而访问这种数组中的元素更昂贵。另外，尽量避免预分配大数组。最好随着发展而增长。最后，不要删除数组中的元素。它会让键变得稀疏。<br>5、标记值：V8用32位表示对象和数字。它用一位来判断是对象（flag = 1）还是整数（flag=0）（这个整数称为SMI（SMall Integer，小整数），因为它是31位）。然后，如果一个数值大于31位，V8将会对数字装箱，将其转化为 double，并创建一个新对象将该数字放在里面。所以要尽可能使用31位有符号数字，从而避免昂贵的转换为JS对象的装箱操作。</p>
<h2 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h2><p>相信很多都知道<code>setTimeout(function, 0)</code>了，就是运用了事件轮询和回调队列的机制，达到让该function在特定的步骤去执行的目的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'cb1'</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*TozSrkk92l8ho6d8JxqF_w.gif"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2017/11/28/docker/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/28/docker/" itemprop="url">记一次 wechaty running on docker 之旅</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-28T19:52:28+08:00">
                2017-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index">
                    <span itemprop="name">FE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/11/28/docker/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/11/28/docker/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>当被告知要结合wechaty做一个自动发消息的微信机器人时，我真的有点懵。看了一下wechaty的文档，推荐通过docker运行。我当时的内心表情就是what? 什么鬼？前端的东西已经让我应接不暇，这些偏后台运维的就一点都不懂了。但能怎么办呢，还带着一个实习生一起做，老大安排的任务，跪着也得完成啊！<br>于是乎，咬着牙硬着头皮开始看各种文档，在本地把脚本运行起来，暴露http接口给我们的管理后台用。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>1、docker for mac    </p>
<p>官网下载docker客户端就行<a href="https://store.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">下载地址</a><br>安装后，直接可以在Mac终端docker info，可以看到docker信息，就成功了。</p>
<p>2、npm和node</p>
<p>为了本地开发方便，不多说了，前端必备环境。</p>
<h2 id="运行例子"><a href="#运行例子" class="headerlink" title="运行例子"></a>运行例子</h2><p>1、在本地创建一个文件夹myWechaty<br>2、<code>npm init</code>创建package.json<br>3、<code>npm install --save qrcode-termial</code><br>4、创建mybot.js <a href="https://github.com/Chatie/wechaty" target="_blank" rel="noopener">官方6行代码</a><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Wechaty &#125; = <span class="built_in">require</span>(<span class="string">'wechaty'</span>) <span class="comment">// import &#123; Wechaty &#125; from 'wechaty'</span></span><br><span class="line"></span><br><span class="line">Wechaty.instance() <span class="comment">// Singleton</span></span><br><span class="line">.on(<span class="string">'scan'</span>, <span class="function">(<span class="params">url, code</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Scan QR Code to login: <span class="subst">$&#123;code&#125;</span>\n<span class="subst">$&#123;url&#125;</span>`</span>))</span><br><span class="line">.on(<span class="string">'login'</span>,       <span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`User <span class="subst">$&#123;user&#125;</span> logined`</span>))</span><br><span class="line">.on(<span class="string">'message'</span>,  <span class="function"><span class="params">message</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;message&#125;</span>`</span>))</span><br><span class="line">.start()</span><br></pre></td></tr></table></figure></p>
<p>5、修改一下scan事件，引入<code>qrcode-terminal</code>，方便直接在控制台显示二维码<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Wechaty &#125; = <span class="built_in">require</span>(<span class="string">'wechaty'</span>) <span class="comment">// import &#123; Wechaty &#125; from 'wechaty'</span></span><br><span class="line"><span class="keyword">const</span> QrcodeTerminal = <span class="built_in">require</span>(<span class="string">'qrcode-terminal'</span>);</span><br><span class="line"></span><br><span class="line">Wechaty.instance() <span class="comment">// Singleton</span></span><br><span class="line">.on(<span class="string">'scan'</span>, <span class="function">(<span class="params">url, code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Scan QR Code to login: <span class="subst">$&#123;code&#125;</span>\n<span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="regexp">/201|200/</span>).test(<span class="built_in">String</span>(code))) &#123;</span><br><span class="line">    <span class="keyword">const</span> loginUrl = url.replace(<span class="regexp">/\/qrcode\//</span>, <span class="string">'/l/'</span>)</span><br><span class="line">    QrcodeTerminal.generate(loginUrl)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'login'</span>,        <span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`User <span class="subst">$&#123;user&#125;</span> logined`</span>))</span><br><span class="line">.on(<span class="string">'message'</span>,   <span class="function"><span class="params">message</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;message&#125;</span>`</span>))</span><br><span class="line">.start()</span><br></pre></td></tr></table></figure></p>
<p>6、在终端进入myWechaty文件夹，并运行<code>docker run -ti --name=mybot --rm --volume=&quot;$(pwd)&quot;:/bot zixia/wechaty mybot.js</code>   </p>
<ul>
<li>命令中的 <code>zixia/wechaty</code>是wechaty包装好的docker镜像，mybot.js是运行于这个镜像之上的一段脚本，这个镜像运行依赖的环境可以通过<a href="https://hub.docker.com/r/zixia/wechaty/~/dockerfile/" target="_blank" rel="noopener">docker hub 上wechaty的dockerfile</a>看到:<br> 依赖了一系列命令，有熟知bash, curl, git, sudo, vim等等，还下载了nodejs，还运行了npm install，也就是说，这个镜像依赖的环境也是我们需要的，我们无需再获取。</li>
<li>关于docker run 命令解释：<br>  a、-ti 可命令交互<br>  b、–name=mybot 创建容器的名称是mybot<br>  c、–rm  退出命令后，自动删除容器<br>  d、–volume=”$(pwd)”:/bot  在镜像外层目录上挂载一个bot文件夹，里面存放的是myWechaty里的内容。</li>
<li>新开终端，<code>docker ps</code> 列出当前所有容器，可以看到有我们的mybot</li>
</ul>
<p>7、终端显示二维码，用微信扫码即可。这样，就可以在终端查看到微信消息了。<br>了解了以上之后，我们就可以在<code>mybot.js</code>中开发我们需要的功能了。</p>
<h2 id="mybot-js中暴露接口"><a href="#mybot-js中暴露接口" class="headerlink" title="mybot.js中暴露接口"></a>mybot.js中暴露接口</h2><p><strong>难以入手的问题</strong><br>在写接口之前，我在想怎么在本地访问呢？现在的环境node已经有了，wechaty本身也有服务，我又该怎么做呢？这个问题困扰了我很久，总之，还是因为对docker环境不了解。<br>几番周折查找，原来就在docker run命令里面设置一个参数就能解决。<br><strong><code>-p 8888:8888</code></strong> ： 将虚拟机器（即mybot容器）的地址端口映射到我们本地端口。<br>在myWechaty mybot.js中，引入：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const express</span> = require(<span class="string">'express'</span>);</span><br><span class="line"><span class="attribute">const app</span> = express();</span><br><span class="line"><span class="attribute">const bodyParser</span> = require(<span class="string">'body-parser'</span>);</span><br></pre></td></tr></table></figure></p>
<p>再对body解析：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">app</span><span class="selector-class">.use</span>(bodyParser.json(&#123;<span class="attribute">limit</span>: <span class="string">'20mb'</span>&#125;));<span class="comment">//设置前端post提交最大内容</span></span><br><span class="line"><span class="selector-tag">app</span><span class="selector-class">.use</span>(bodyParser.urlencoded(&#123;<span class="attribute">limit</span>: <span class="string">'20mb'</span>, <span class="attribute">extended</span>: false&#125;));</span><br><span class="line"><span class="selector-tag">app</span><span class="selector-class">.use</span>(bodyParser.text());</span><br></pre></td></tr></table></figure></p>
<p>再添加一段监听日志代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8888</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>终端：<br>1、<code>npm install --save express body-parser</code><br>2、<code>docker run -ti --name=mybot --rm --volume=&quot;$(pwd)&quot;:/bot -p 8888:8888 zixia/wechaty mybot.js</code>   </p>
<p>看到监听日志打出来了，也有微信消息。 在浏览器中访问<code>localhost:8888</code>, Hello World!<br>到这里了，暴露接口不就是顺手拈来的事情了么！    </p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>到此，基本上开发就是这样了，跟平常做node开发一样。最后，就是看是否需要将开发的内容打包成镜像发布，还是直接就这样运行就行了。打包镜像的话，就是注意Dockerfile的配置，进行docker build。   </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://camiler.github.io/2017/10/13/ioshole/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="camiler lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="camiler">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/13/ioshole/" itemprop="url">ios的坑，你填过多少</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-13T18:59:12+08:00">
                2017-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index">
                    <span itemprop="name">FE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/13/ioshole/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2017/10/13/ioshole/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于user-select"><a href="#关于user-select" class="headerlink" title="关于user-select"></a>关于user-select</h3><p><strong>现象：</strong><br>    input输入框无法focus，输入时只能输入一个字符，后面再输入就好像无法聚焦一样，再重新点击聚焦，又可以输入第二个字符，而且显示在第一个字符的前面。<br><strong>解决：</strong><br>    发现这个问题是在一个react项目中，尝试过用通过不断触发focus，但也无疾而终。发现css的样式里面有个user-select设置为none, 改成initial就好了。<br>    最终通用css：对不是input和textarea以及只读的input和textarea才设置user-select为none。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-pseudo">:not(input)</span><span class="selector-pseudo">:not(textarea)</span>, <span class="selector-tag">input</span><span class="selector-attr">[readonly]</span>, <span class="selector-tag">textarea</span><span class="selector-attr">[readonly]</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-khtml-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">  <span class="attribute">outline-style</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/10819565/user-selectnone-causes-input-field-to-be-inaccessible-on-safari" target="_blank" rel="noopener">参考答案</a>     </p>
<h3 id="input光标隐藏"><a href="#input光标隐藏" class="headerlink" title="input光标隐藏"></a>input光标隐藏</h3><p><strong>现象：</strong><br>    底层的input聚焦后，触发其他条件显示一个弹层时，光标会显示在弹层上面。<br><strong>解决：</strong></p>
<ul>
<li>想法1： 触发弹层显示后，让input失去焦点。  用的react中的 this.refs.input.blur() 貌似没起作用。</li>
<li>想法2： 触发弹层后，通过如下css隐藏光标。   </li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: -<span class="number">999em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/driftyco/ionic/issues/26" target="_blank" rel="noopener">参考答案</a></p>
<h3 id="window-scrollTo"><a href="#window-scrollTo" class="headerlink" title="window.scrollTo"></a>window.scrollTo</h3><p><strong>现象：</strong><br>    ios中嵌入H5页面，页面为长列表，点击单个列表进入详情后，再回退。页面卡顿，没有展示内容，点击稍微滑动一下页面，内容才展示出来。在componentDidMount中用window.scrollTo(0, 0)并没有效果。<br><strong>解决：</strong>   </p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/11845371/window-scrollto-is-not-working-in-mobile-phones" target="_blank" rel="noopener">参考答案</a></p>
<h3 id="position-fixed问题"><a href="#position-fixed问题" class="headerlink" title="position: fixed问题"></a>position: fixed问题</h3><p><strong>现象：</strong><br>    在iOS上，当点击input出现键盘输入时，fixed的元素会失效，iOS会认为时absolute的。<br><strong>解决：</strong><br>    当然，在不会出现键盘输入情况的页面时，应该是可以放心大胆的用fixed做布局的。如果有键盘输入，可以通过将除了fixed的其他全部内容放到一个绝对定位的容器中。示例代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,user-scalable=no"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        html,body&#123;</span></span><br><span class="line"><span class="undefined">            width: 100%;</span></span><br><span class="line"><span class="undefined">            height: 100%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="undefined">            position: relative;</span></span><br><span class="line"><span class="undefined">            height: 100%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.content-wrap</span>&#123;</span></span><br><span class="line"><span class="undefined">            position: absolute;</span></span><br><span class="line"><span class="undefined">            top: 0;</span></span><br><span class="line"><span class="undefined">            left: 0;</span></span><br><span class="line"><span class="undefined">            right: 0;</span></span><br><span class="line"><span class="undefined">            bottom: 2rem;</span></span><br><span class="line"><span class="undefined">            min-height: 100%;</span></span><br><span class="line"><span class="undefined">            -webkit-touch-scrolling: touch;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.dec-button-wrap</span>&#123;</span></span><br><span class="line"><span class="undefined">            position: fixed;</span></span><br><span class="line"><span class="undefined">            z-index: 999;</span></span><br><span class="line"><span class="undefined">            bottom: 0;</span></span><br><span class="line"><span class="undefined">            left: 0;</span></span><br><span class="line"><span class="undefined">            width: 100%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.modal-msk</span>&#123;</span></span><br><span class="line"><span class="undefined">            position: fixed;</span></span><br><span class="line"><span class="undefined">            top: 0;</span></span><br><span class="line"><span class="undefined">            left: 0;</span></span><br><span class="line"><span class="undefined">            right: 0;</span></span><br><span class="line"><span class="undefined">            bottom: 0;</span></span><br><span class="line"><span class="undefined">            width: 100%;</span></span><br><span class="line"><span class="undefined">            height: 100%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(0, 0, 0, <span class="selector-class">.5</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"decoration"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-wrap"</span>&gt;</span></span><br><span class="line">        // other all content</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"button-wrap"</span>&gt;</span></span><br><span class="line">        // fixed button at bottom</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-msk"</span>&gt;</span></span><br><span class="line">        // fixed modal</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外还可以通过将内容包裹在一个具有CSS3滑动属性的div中。通过变换translateY属性实现滚动。参考插件<a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">iscroll</a> 以及 <a href="https://github.com/AlloyTeam/AlloyTouch" target="_blank" rel="noopener">AlloyTouch</a></p>
<h3 id="iOS-微信问题"><a href="#iOS-微信问题" class="headerlink" title="iOS 微信问题"></a>iOS 微信问题</h3><p><strong>现象：</strong><br>    1、在微信iOS上，页面加载就白屏。<br>    2、分享设置似乎没成功？首页进去分享没有问题，后面的页面分享后没有那些配置信息。<br><strong>解决：</strong><br>    1、微信里面的这种白屏，不显示之类的问题，多半就是JS报错了，但不好调试。所以，首先微信页面用微信开发者工具先过一遍，看有没有报错。当项目需要适配自己公司的APP，适配微信的时候，再将适配部分的代码多理理，理清楚。说不定就发现有些有漏洞的地方了。<br>    2、分享问题，深觉是微信最难调试之首，不能更多了。相对耗费时间精力，而且有的时候安卓和IOS表现还不一样。不过，大部分问题通过debug还是可以看出来，微信开发者文档里面也有<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">错误信息问题的原因</a>。<br>    迄今为止，最奇葩的问题是 针对 <strong>单页应用</strong>，如果只在进入页面时，wx.config, ready就调用一次，安卓分享invalid signature，IOS正常。于是看文档，原来可能是地址的原因，所以在每个路由页面都config ready 了一次，安卓OK了！结果IOS又有问题。但debug时，并没有报错。怀疑还是地址的原因，然后复制了IOS路由的地址，发现所有路由地址都是首次进去的那个地址。<br>    这样。。针对IOS，就config一次，安卓就每个页面都调一次。或者缓存一下首页地址，判断是安卓就更改地址，重新调用signature，并config。但其实还有点问题，IOS分享的时候 有的页面分享OK，有的还是显示首页的地址。感觉已经尽力了，精疲力竭了。时间不等人，这个先暂时放一放，毕竟不影响业务。</p>
<p>参考资料：<br><a href="https://blog.csdn.net/github_37519401/article/details/78406159" target="_blank" rel="noopener">csdn</a><br><a href="https://github.com/vuejs/vue-router/issues/481" target="_blank" rel="noopener">vue issue</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="camiler lee">
            
              <p class="site-author-name" itemprop="name">camiler lee</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/camiler" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:liyue_suc@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zcfy.cc/@camiler/article" target="_blank" title="翻译">
                      
                        <i class="fa fa-fw fa-globe"></i>翻译</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">camiler lee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 't8pkhPWyP7indcApWvQT4tCx-gzGzoHsz',
        appKey: 'I85dXiy6K2DuDeey1N0xQyA6',
        placeholder: 'say somthing',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
