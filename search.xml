<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[jest enzyme进行react项目测试实践小结]]></title>
      <url>/2018/12/19/react-test/</url>
      <content type="html"><![CDATA[<blockquote>
<p>“如果一个开源包没有一行测试代码，谁敢用？”      </p>
</blockquote>
<p>一直觉得页面代码无法进行代码测试，就算是代码测试也是内置了浏览器引擎，不然怎么模拟事件点击、网络请求。所以，要写出来，还不如自己在页面上点击来的方便直接。但凭这句话，我怎么样也要看看前端测试代码怎么写？有没有必要写？</p>
<p>搜罗了一堆关于react测试的文章，选择了jest结合enzyme来实践。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>install babel相关支持，enzyme react版本支持<br><code>npm install --save-dev babel-core@^7.0.0-bridge.0 @babel/core babel-jest enzyme enzyme-adapter-react-16 jest jest-cli react-test-renderer</code></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>项目中需要Babel进行编译，所以简单的jest默认配置无法正常运行，需要为jest设置一些特殊配置。<br>.jest.js文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  verbose: <span class="literal">true</span>,</span><br><span class="line">  setupFiles: [<span class="string">'./test/setup.js'</span>],</span><br><span class="line">  testURL: <span class="string">'http://localhost:3000'</span>, <span class="comment">// 测试环境URL</span></span><br><span class="line">  moduleFileExtensions: [<span class="string">'js'</span>, <span class="string">'jsx'</span>], <span class="comment">// 单元测试文件检测后缀名</span></span><br><span class="line">  moduleDirectories: [<span class="string">"node_modules"</span>],</span><br><span class="line">  transformIgnorePatterns: [<span class="string">"/node_modules/"</span>],</span><br><span class="line">  coveragePathIgnorePatterns: [<span class="string">"/node_modules/"</span>],</span><br><span class="line">  modulePathIgnorePatterns: [<span class="string">"/node_modules/"</span>],</span><br><span class="line">  unmockedModulePathPatterns: [</span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/node_modules/react/"</span>,</span><br><span class="line">    <span class="string">"&lt;rootDir&gt;/node_modules/react-dom/"</span></span><br><span class="line">  ],</span><br><span class="line">  collectCoverage: <span class="literal">true</span>,</span><br><span class="line">  moduleNameMapper: &#123; <span class="comment">// mock模块</span></span><br><span class="line">    <span class="string">'\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$'</span>: <span class="string">'&lt;rootDir&gt;/test/__mocks__/fileMock.js'</span>,</span><br><span class="line">    <span class="string">'\\.(css|less)$'</span>: <span class="string">'identity-obj-proxy'</span>, <span class="comment">//告诉jest将webpack引用的css模拟导入，这样就可以按className原样去查找</span></span><br><span class="line">    <span class="string">'^@/(.*)$'</span>: <span class="string">'&lt;rootDir&gt;/src/$1'</span> <span class="comment">//webpack配置了 resolve alias: &#123;'@': path.resolve(__dirname, './src')&#125; 需要对应jest模块名称解析</span></span><br><span class="line">  &#125;,</span><br><span class="line">  transform: &#123;</span><br><span class="line">    <span class="string">"^.+\\.jsx?$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span>,</span><br><span class="line">    <span class="string">"^.+\\.js?$"</span>: <span class="string">"&lt;rootDir&gt;/node_modules/babel-jest"</span>  <span class="comment">//安装babel-jest</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>.babelrc</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">    <span class="string">"@babel/preset-react"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>package.json scripts增加 <code>&quot;test&quot;: &quot;jest --config .jest.js&quot;</code></p>
<p>新建test文件夹，创建componentXX.test.js就可以开始编写测试用例了。</p>
<h2 id="如何编写？"><a href="#如何编写？" class="headerlink" title="如何编写？"></a>如何编写？</h2><h3 id="enzyme-v3-渲染API"><a href="#enzyme-v3-渲染API" class="headerlink" title="enzyme v3 渲染API"></a>enzyme v3 渲染API</h3><h4 id="shallow"><a href="#shallow" class="headerlink" title="shallow"></a><code>shallow</code></h4><p>浅层比较，state和props决定渲染结果。不会影响子组件，所以这类API通常用在最小单元组件或状态组件的测试，简单判断渲染结构、内部state是否和预想一致。可以随时<code>setProps</code>，<code>setState</code>, <code>setContext</code>改变数据。<br>v3版本中，shallow会调用react的<code>componentDidMount</code>和<code>componentDidUpdate</code>周期，所以可以模拟事件，查找节点，获取选择器进行结果的查询。</p>
<h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a><code>mount</code></h4><p>完整的DOM渲染，深层渲染。可以用于测试有DOM API的交互，或包裹在高阶组件中的组件，包含子组件的组件。完整的DOM渲染至少需要运行在一个像浏览器的环境中，如果不是浏览器环境，推荐使用<a href="https://github.com/tmpvar/jsdom" target="_blank" rel="noopener">jsdom</a>模拟。<br>与其他两个API不同的是，mount实际上会把组件挂载到DOM上，就是说mount中，如果用的是相同的DOM，它们会相互影响。必要时，使用<code>unmount()</code>清理。</p>
<h4 id="render"><a href="#render" class="headerlink" title="render"></a><code>render</code></h4><p>用于将react组件渲染为静态HTML，对HTML结构进行分析。使用<code>cheerio</code>解析HTML。所以一般不用该方法。有可能的用法之一是：检测react中通过dangerouslySetInnerHTML动态生成的HTML。</p>
<h3 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h3><p>惯用格式：it只是作为test的别名，两者一样。官方使用test。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'des'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'des'</span>, () =&gt; &#123;</span><br><span class="line">    expect().toEqual();</span><br><span class="line">  &#125;);</span><br><span class="line">  test(<span class="string">'des'</span>, () =&gt; &#123;</span><br><span class="line">    expect().toBe();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="如何写测试用例"><a href="#如何写测试用例" class="headerlink" title="如何写测试用例"></a>如何写测试用例</h3><p>测试最大的特点就是覆盖足够的逻辑点及边界。前端测试也是一样。   </p>
<p>针对react应用来说，内部state的变化是否按照预期那样在流转？react周期是不是在对的时间进行了调用，比如：props变化后，是否确实调用了<code>componentWillReceiveProps</code>了呢？当然周期的调用也可以通过state的流向侧面反应出来。模拟事件后，事件里的逻辑通过哪些现象可以得到印证？   </p>
<p>另外，我们知道，组件最终渲染结果是根据props和state决定的，所以如何确定相同的props，state确定得到了同一个DOM，而不同的props得到的DOM版本是不一样的？这些都可以通过enzyme的方法得到解决。</p>
<p>至于解决方法具体查看<a href="https://airbnb.io/enzyme/docs/api/" target="_blank" rel="noopener">enzyme api文档</a>，文档很简单，也有简单示例，先大致浏览一遍是干什么的，用时才有印象。</p>
<p>jest的断言方法也一样。另外jest提供了常用的<a href="https://jestjs.io/docs/en/mock-functions" target="_blank" rel="noopener">function</a>、<a href="https://jestjs.io/docs/en/es6-class-mocks" target="_blank" rel="noopener">es6 class</a>,  <a href="https://jestjs.io/docs/en/timer-mocks" target="_blank" rel="noopener">timer</a> mock功能，也可以<a href="https://jestjs.io/docs/en/manual-mocks" target="_blank" rel="noopener">人为mock</a>，通常用来mock数据。</p>
<h2 id="实践之后"><a href="#实践之后" class="headerlink" title="实践之后"></a>实践之后</h2><p>前期配置调试了很久，babel版本问题，import无法识别等等，前端配置越来越复杂，想如后端那样集构建测试一体确实不容易。前端真的要这样复杂么？毕竟本质来说就是运行在浏览器上的特定结构。当然这个问题答案肯定是既有好处也有坏处，我也总是徘徊不定。配置这些真的让人头疼，但框架的运用确实提高了效率。</p>
<p>回归正题，在编写测试代码时，我会问自己这个组件到底是做什么，要实现什么功能，会先梳理一遍内部逻辑才能开始想从哪里写。所以编写测试用例能够加深对代码的理解。测试代码运行后，会发现和预期不一致，再重新看组件逻辑，会发现有些地方处理有问题，而这个问题只不过业务没有覆盖到或者说没有用到，而作为组件需要提供这样一个选项，但这个值业务没有完全覆盖。这些都是做测试的优势。</p>
<p>但初次写测试代码，尤其在项目已经完善后期，编写测试用例是个大工程。当然只要能完整的完成一个项目的所有测试用例，在业务模式一致，框架相同的条件下，后面的项目都可以套用了。</p>
<p>另外，我感受到的是，周围很少有前端完善测试用例，这也跟国内开发环境有关。产品快速迭代，需求不断更改，开发时间都不够，哪里有时间关注前端代码测试，只要页面测试后满足需求就可以了。</p>
<p>而作为工程本身而言，完整的测试覆盖应该是一种责任和义务。</p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[redux理解-日常小记]]></title>
      <url>/2018/10/11/redux-note/</url>
      <content type="html"><![CDATA[<h2 id="redux应用的好处"><a href="#redux应用的好处" class="headerlink" title="redux应用的好处"></a>redux应用的好处</h2><p>1、创造完全无状态组件<br>   除了UI基本组件用react内部的state，容器组件可以完全用store来存储进行状态变化，而无状态组件可以减少内部state和props之间的冲突，没有state了，完全由props决定，而props又来自一个store状态树，数据结构一目了然。<br>2、统一数据管理<br>   因为是SPA应用，store的数据只有在页面强制刷新后才会初始化，所以对于单页应用来说，统一数据管理可以减少数据请求、临时存储数据、尤其是移动端页面分步填写表单进行set store，即便在router变化后，之前的数据也能从store取到。</p>
<p>以上，数据和视图就很清晰了，会看到数据结构全在reducer里面，改变数据只需要进行不同的action进行触发设置state。MVVM，M是整个应用的数据模型，V是视图，VM就是store以及操作store的action和获取store的reducer了。</p>
<h2 id="坏处："><a href="#坏处：" class="headerlink" title="坏处："></a>坏处：</h2><p>1、很多模版代码<br>2、对于简单的react应用，内部state也够用，加redux增加了复杂度   </p>
<p>其实一直没get到好处，之前我会觉得用redux会写很多模版代码，也并没有深刻理解好在什么地方。最近一直在找替换单页应用中的toast、loading方案，感觉都没有用redux来做合适，再搜罗了一些博客，好像慢慢突然理解了。再回头看我现在的单页项目，好好组织下数据，是不是可以更清晰。</p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[React16.4常用API整理]]></title>
      <url>/2018/07/20/react-api/</url>
      <content type="html"><![CDATA[<p>边看文档边整理下，确实通畅了很多。下图是目前最新React16.4版本的常用API：</p>
<p><img src="/img/reactjs16.4-API.png" width="100%"></p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[迭代器、生成器]]></title>
      <url>/2018/04/17/iterator-generator/</url>
      <content type="html"><![CDATA[<h2 id="迭代协议"><a href="#迭代协议" class="headerlink" title="迭代协议"></a>迭代协议</h2><p>协议：可以被任何遵循某些约定的对象来实现。</p>
<h3 id="可迭代协议"><a href="#可迭代协议" class="headerlink" title="可迭代协议"></a>可迭代协议</h3><p>允许JS对象去定义或定制它们的迭代行为。这个对象中必须实现@@iterator方法，即这个对象的属性（包括原型链上）必须有一个Symbol.iterator的属性。该属性返回一个对象的无参函数。</p>
<p>那么，也就是说通过 <code>typeof someObj[Symbol.iterator] === &#39;function&#39;</code>就可以判断这个对象是否可迭代。</p>
<p>JS中内置的可迭代对象有这些：String, Array, TypedArray(类数组), Map, Set。</p>
<h3 id="可迭代运用"><a href="#可迭代运用" class="headerlink" title="可迭代运用"></a>可迭代运用</h3><p>1、<code>for - of</code>: 可迭代对象都可以用for-of进行循环遍历<br>关于 <code>for-of</code> <code>for-in</code> <code>forEach</code>之间的区别可以参考下面这个栗子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'fasdfadsf'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);  <span class="comment">//读取键名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----分割线----'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 读取键值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----分割线----'</span>);</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'b'</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// SyntaxError</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'b'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 没报错，但并没返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'----分割线----'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item); <span class="comment">// 读取键值</span></span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'a'</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'b'</span>)&#123;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 正常，显示到b就停止遍历了</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="string">'c'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// SyntaxError</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、对可迭代对象的解构<br>3、扩展运算符（…）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line"><span class="keyword">var</span> [first, ...rest] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(rest);  <span class="comment">// ['b', 'c', 'd']</span></span><br></pre></td></tr></table></figure></p>
<p>4、yield<em> ： yield</em>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> it = gen();</span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 3&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 4&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: true, value: undefined&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h3><p>定义了一种标准方式来产生一个有限或无限序列的值。迭代器上实现了一个next()方法，并且next()方法返回两个值：<br>1、done(boolean)：表示是否迭代完成。<br>2、value: 任何值，done为true时可省略。</p>
<p>下面是自定义一个对于对象的迭代器：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myObjIterator</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Object]'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx &lt; keys.length ? &#123;</span><br><span class="line">          value: obj[keys[idx++]], <span class="attr">done</span>: <span class="literal">false</span></span><br><span class="line">        &#125; : &#123;</span><br><span class="line">          done: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"not object"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = myObjIterator(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: false, value: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123;done: true&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>以上，我们可以自定义一个迭代器，有next方法就行，但是需要显示的维护内部状态，所以工作量也会无形中增多。而且并没有实现它的可迭代性，这就是一个Non-well-formed（(非-良好-格式化的）的可迭代对象。所以，生成器孕育而生。</p>
<h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h2><p>生成器允许你定义一个包含自有迭代算法的函数，还可以自动维护自己的状态。其语法就是<code>function*</code></p>
<p>生成器对象 既是迭代器也是可迭代对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aGeneratorObject = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> aGeneratorObject.next;  <span class="comment">// "function" 有next方法，是一个迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> aGeneratorObject[<span class="built_in">Symbol</span>.iterator];<span class="comment">// "function" 有Symbol.iterator属性，可迭代</span></span><br><span class="line"></span><br><span class="line">aGeneratorObject[<span class="built_in">Symbol</span>.iterator]() === aGeneratorObject; <span class="comment">// true  这是一个设计优良的可迭代对象</span></span><br><span class="line"></span><br><span class="line">[...aGeneratorObject]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>对于上面第一个实现对象迭代器的例子中，要实现它的可迭代性，可以像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = <span class="built_in">Object</span>.values(<span class="keyword">this</span>).sort();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> values) &#123;</span><br><span class="line">    <span class="keyword">yield</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(...obj); <span class="comment">// 1  2</span></span><br></pre></td></tr></table></figure>
<h3 id="Generator-语法说明"><a href="#Generator-语法说明" class="headerlink" title="Generator 语法说明"></a>Generator 语法说明</h3><p>1、调用一个Generator函数时，会返回一个内部指针对象，不会返回任何结果。<br>2、每一个yield或者return就是一个状态，通过next，将指针按顺序指向这些状态。<br>3、<code>yield</code> 作为一个表达式，本身没有返回值，但next方法可以带一个参数，这个参数会被当作上一个yield表达式的返回值</p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[「翻译」Node.js 事件循环、计时器和process.nextTick()]]></title>
      <url>/2018/02/28/nodejsevent/</url>
      <content type="html"><![CDATA[<h3 id="什么是事件循环？"><a href="#什么是事件循环？" class="headerlink" title="什么是事件循环？"></a>什么是事件循环？</h3><p>事件循环允许Node.js执行非阻塞I/O操作 - 尽管JavaScript是单线程的 - 只要可能就将操作卸载到系统内核。</p>
<p>由于大多数现代内核都是多线程的，他们可以在后台处理多个正在执行的操作。 当其中一个操作完成时，内核会通知Node.js，以便可以将相应的回调添加到轮询队列中得到最终执行。 我们将在本主题后面进一步详细解释这一点。</p>
<h3 id="事件循环解释"><a href="#事件循环解释" class="headerlink" title="事件循环解释"></a>事件循环解释</h3><p>当Node.js启动时，它就会初始事件循环，处理提供的输入脚本（或者进入REPL：Read-Eval-Print-Loop，本文不会提及。），这可能会导致异步API调用，调度定时器或调用<code>process.nextTick()</code>，然后开始处理事件循环。</p>
<p>下面的图表展示的是一个事件循环的操作顺序的简单概述：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │       <span class="built_in"> check </span>         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure></p>
<p>注意：每个方框将被称为事件循环的一个“阶段”。</p>
<p>每个阶段有一个要执行的先进先出的回调队列。虽然每个阶段都有其特定的方式，但通常情况下，当事件循环进入给定阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列耗尽或已执行回调的最大数量。当队列耗尽或达到回调限制时，事件循环将移至下一个阶段，依此类推。</p>
<p>由于这些操作中的任何一个都可以调度更多操作，并且在轮询阶段处理的新事件由内核排队，所以轮询事件可以在轮询事件正在处理时排队。 因此，长时间运行的回调可以使轮询阶段的运行时间远远超过计时器的阈值。 有关更多详细信息，请参阅定时器和轮询部分。</p>
<p><strong>注意</strong>：Windows和Unix/Linux实现之间略有差异，但对这里的表述不重要。 最重要的部分就在这里。 实际上有七八个步骤，但我们关心的那些 - Node.js实际使用的那些 - 就是上述这些。</p>
<h3 id="阶段概述"><a href="#阶段概述" class="headerlink" title="阶段概述"></a>阶段概述</h3><ul>
<li>timers: 这个阶段执行由<code>setTimeout()</code> 和 <code>setInterval()</code> 注册的回调。</li>
<li>I/O callbacks: 执行几乎所有的回调，除了关闭回调，由定时器注册的回调，和<code>setImmediate()</code></li>
<li>idle, prepare: 只是内部使用</li>
<li>poll: 检索新的I/O事件；在占用时节点将会阻塞在这里。</li>
<li>check: <code>setImmediate()</code>回调会在这里被调用。</li>
<li>close callbacks: 比如<code>socket.on(&#39;close&#39;, ...)</code>。</li>
</ul>
<p>在事件循环的每次运行之间，Node.js会检查它是否正在等待任何异步I/O或定时器，并在没有时清除关闭。</p>
<h3 id="阶段详解"><a href="#阶段详解" class="headerlink" title="阶段详解"></a>阶段详解</h3><h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>计时器规定了一个阈值，这个阈值是注册的回调才可能被执行的时间，而不是人们希望执行的确切时间。 定时器回调会尽可能早的在指定的时间过后执行; 但是，操作系统调度或其他回调的运行可能会延迟它们。</p>
<p><strong>注意</strong>：技术上来讲，当计时器被执行时，poll阶段会进行控制。</p>
<p>比如：假设你注册了一个延时是在100ms之后调用，然后，你的脚本开始是异步读取一个文件花了95ms:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  fs.readFile(<span class="string">'/path/to/file'</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// do someAsyncOperation which takes 95 ms to complete</span></span><br><span class="line">someAsyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do something that will take 10ms...</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - startCallback &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当事件循环进入轮询阶段时，它有一个空队列（<code>fs.readFile()</code>尚未完成），因此它将等待剩余的毫秒数，直到计时器的阈值最早达到。 当等待了95ms后，<code>fs.readFile()</code>完成读取文件，并且需要10ms来完成添加回调到轮询队列并执行的操作。当回调完成时，队列中没有更多的回调了，所以事件循环会看到已经达到最快计时器的阈值，然后回到计时器阶段以执行计时器的回调。在这个例子中，你会看到被调度的定时器和它正在执行的回调之间的总延迟将是105ms。</p>
<p>注意：为防止轮询阶段时事件循环挨饿空闲，在停止轮询之前，为了执行更多的事件，libuv（实现Node.js事件循环和平台所有异步行为的C库）也有一个硬性最大值（取决于系统）。</p>
<h4 id="I-O-callbacks"><a href="#I-O-callbacks" class="headerlink" title="I/O callbacks"></a>I/O callbacks</h4><p>此阶段是执行某些系统操作（如TCP错误类型）注册的回调。例如，如果尝试连接时TCP套接字收到ECONNREFUSED，则某些*nix系统要等待报告该错误。这将排队在I/O回调阶段执行。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>在轮询阶段有两个主要功能：<br>    对阈值已到的定时器执行脚本，然后处理轮询队列中的事件。<br>当事件循环进入轮询阶段并且没有计时器时，会发生以下两件事之一：</p>
<ul>
<li>如果轮询队列不为空，则事件循环将遍历其回调队列，同步执行它们，直到队列耗尽或达到系统相关的强制限值。</li>
<li><p>如果轮询队列为空，则还发生以下两件事之一：</p>
<ul>
<li>如果脚本已通过<code>setImmediate()</code>进行了调度，则事件循环将结束轮询阶段并继续执行检查阶段以执行这些被调度的脚本。</li>
<li>如果脚本没有通过<code>setImmediate()</code>进行调度，则事件循环将等待将回调添加到队列中，然后立即执行它们。</li>
</ul>
</li>
</ul>
<p>一旦轮询队列为空，事件循环将检查已达到时间阈值的定时器。 如果一个或多个定时器准备就绪，则事件循环将回退到定时器阶段以执行这些定时器的回调。</p>
<h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>此阶段允许在轮询阶段结束后立即执行回调。 如果轮询阶段变得空闲并且脚本已经通过<code>setImmediate()</code>排队，则事件循环可能会继续检查阶段而不是等待。</p>
<p><code>setImmediate()</code>实际上是一个特殊的定时器，它在事件循环的一个单独的阶段中运行。它使用libuv API来调度回调，以在轮询阶段完成后执行。</p>
<p>通常，随着代码的执行，事件循环将最终进入轮询阶段，在那里它将等待传入的连接，请求等。但是，如果使用<code>setImmediate()</code>注册了回调并且轮询阶段变为空闲，事件循环将继续进行检查阶段，而不是等待轮询事件。</p>
<h4 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h4><p>如果套接字或句柄突然关闭（<code>例如socket.destroy()</code>），则在此阶段将触发’close’事件。 否则它将通过<code>process.nextTick()</code>触发。</p>
<h3 id="setImmediate-vs-setTimeout"><a href="#setImmediate-vs-setTimeout" class="headerlink" title="setImmediate() vs setTimeout()"></a><code>setImmediate()</code> vs <code>setTimeout()</code></h3><p><code>setImmediate</code> and <code>setTimeout()</code> 很相似，但其行为方式是不一样的，这取决于它们何时被调用。</p>
<p><code>setImmediate()</code>用于在当前轮询阶段完成后执行脚本。<br><code>setTimeout()</code>在经过最小阈值（以毫秒为单位）后调度脚本运行。<br>定时器执行的顺序取决于它们被调用的上下文。 如果两者都是在主模块内调用的，那么时序将受到进程性能的限制（可能会受到计算机上运行的其他应用程序的影响）。</p>
<p>例如，如果我们运行以下不在I/O周期内的脚本（即主模块），则两个定时器的执行顺序是非确定性的，因为它受过程执行的约束：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> timeout_vs_immediate.js</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">node</span> <span class="title">timeout_vs_immediate</span>.js</span><br><span class="line">timeout</span><br><span class="line">immediate</span><br><span class="line"></span><br><span class="line">$ <span class="keyword">node</span> <span class="title">timeout_vs_immediate</span>.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>但是，如果在I/O周期内移动这两个调用，则立即回调总是首先执行：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> timeout_vs_immediate.js</span><br><span class="line">const fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">node</span> <span class="title">timeout_vs_immediate</span>.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br><span class="line"></span><br><span class="line"><span class="keyword">node</span> <span class="title">timeout_vs_immediate</span>.js</span><br><span class="line">immediate</span><br><span class="line">timeout</span><br></pre></td></tr></table></figure>
<p>使用<code>setImmediate()</code>超过<code>setTimeout()</code>的主要优点是: 如果在I/O周期内进行调度，<code>setImmediate()</code>将始终在任何计时器之前被执行，不管当前有多少个计时器。</p>
<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a><code>process.nextTick()</code></h3><h4 id="理解-process-nextTick"><a href="#理解-process-nextTick" class="headerlink" title="理解 process.nextTick()"></a>理解 process.nextTick()</h4><p>您可能已经注意到<code>process.nextTick()</code>没有显示在图中，即使它是异步API的一部分。 这是因为<code>process.nextTick()</code>在技术上并不是事件循环的一部分。 相反，nextTickQueue将在当前操作完成后处理，而不管事件循环处于当前哪个阶段。</p>
<p>回顾那张图，你在给定的阶段任何时候调用<code>process.nextTick()</code>，所有传递给<code>process.nextTick()</code>的回调都将在事件循环继续之前被解决。 这可能会造成一些不好的情况，因为它允许你通过递归调用<code>process.nextTick()</code>来“饿死”你的I/O，从而阻止事件循环到达轮询阶段。</p>
<h4 id="为什么可以这样"><a href="#为什么可以这样" class="headerlink" title="为什么可以这样?"></a>为什么可以这样?</h4><p>为什么像这样的东西被包含在Node.js中？ 其中一部分源于它的设计理念就是，即使不需要，API也应该始终是异步的。以此代码为例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">apiCall</span>(<span class="params">arg, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'string'</span>)</span><br><span class="line">    <span class="keyword">return</span> process.nextTick(callback,</span><br><span class="line">                            <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'argument should be string'</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码进行参数检查，如果不正确，它会将错误传递给回调函数。最近更新的API允许将参数传递给<code>process.nextTick()</code>，允许它将回调后传递的任何参数作为参数传播给回调函数，这样就不必嵌套函数了。</p>
<p>我们正在做的是将错误传递给用户，但只有在我们允许执行用户其余的代码之后。通过使用<code>process.nextTick()</code>，我们就能保证<code>apiCall()</code>总是在剩余代码之后且在允许事件循环继续之前运行其回调。为了达到这个目的，JS调用堆栈允许展开，然后立即执行提供的回调，这样就允许了开发者对<code>process.nextTick()</code>进行递归调用，而不会出现RangeError错误：超出v8的最大调用堆栈大小。</p>
<p>这种理念会造成一些潜在的困境。看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个异步签名，但是调用了异步回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123; callback(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在someAsyncApiCall完成之前回调被调用了.</span></span><br><span class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一旦someAsyncApiCall完成, bar不会指向任何值</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// undefined</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>用户定义<code>someAsyncApiCall()</code>具有异步签名，但它实际上是同步运行的。当它被调用时，提供给<code>someAsyncApiCall()</code>的回调将在事件循环的相同阶段被调用，因为<code>someAsyncApiCall()</code>实际上并不会异步执行任何操作。 因此，回调会尝试引用<code>bar</code>，即使它在作用域中可能没有该变量，因为该脚本无法运行到完成状态。</p>
<p>通过将回调放置在<code>process.nextTick()</code>中，脚本仍然具有运行到完成的能力，允许在调用回调之前对所有变量，函数等进行初始化。 它还具有不允许事件循环继续的优点。 在事件循环被允许继续之前，告知用户出错了可能是有用的。这是前一个使用<code>process.nextTick()</code>的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncApiCall</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">someAsyncApiCall(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>, bar); <span class="comment">// 1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">bar = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>这里是个真实的例子:</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">server.<span class="literal">on</span>(<span class="string">'listening'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>当只有一个端口被传递时，该端口被立即绑定。 所以，’listening’回调可以立即被调用。 问题是<code>.on（&#39;listening&#39;）</code>回调不会在那个时候设置。</p>
<p>为了解决这个问题，’listening’事件在<code>nextTick()</code>中排队等待脚本运行完成。 这允许用户设置他们想要的任何事件处理程序。</p>
<h3 id="process-nextTick-vs-setImmediate"><a href="#process-nextTick-vs-setImmediate" class="headerlink" title="process.nextTick() vs setImmediate()"></a>process.nextTick() vs setImmediate()</h3><p>正如用户担心的，这里有两个方法很相似，但他们的名称有点让人困惑。</p>
<p><code>process.nextTick()</code>在同一阶段立即触发<br><code>setImmediate()</code>触发后面的迭代或者事件循环的“tick”<br>实质上，名称应该交换一下。 <code>process.nextTick()</code>比<code>setImmediate()</code>更快立即触发，但这是过去的人为因素，不太可能改变。修改这个转换会使npm上大部分包垮掉。 每天都有更多的新模块被添加，这意味着我们每多等一天，就会发生更多潜在损害。虽然他们很让人混淆，但名字本身不会改变。</p>
<p>我们建议开发者在所有情况都使用<code>setImmediate()</code>，因为这更容易理解。（而且使得代码在更多环境中兼容，比如浏览器JS中。）</p>
<h3 id="为什么使用-process-nextTick"><a href="#为什么使用-process-nextTick" class="headerlink" title="为什么使用 process.nextTick()?"></a>为什么使用 process.nextTick()?</h3><p>有两个主要原因：</p>
<p>1、允许用户处理错误，清理任何不需要的资源，或者可能在事件循环继续之前再次尝试请求</p>
<p>2、有时需要在调用堆栈解除之后但事件循环继续之前允许回调运行。</p>
<p>下面这个简单的例子就符合用户期望：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const server = net.createServer();</span><br><span class="line">server.<span class="literal">on</span>(<span class="string">'connection'</span>, <span class="function"><span class="params">(conn)</span> =&gt;</span> &#123; &#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>);</span><br><span class="line">server.<span class="literal">on</span>(<span class="string">'listening'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123; &#125;);</span><br></pre></td></tr></table></figure></p>
<p>假设<code>listen()</code>在事件循环的开始处运行，但监听<code>listening</code>的回调放置在<code>setImmediate()</code>中。 除非传递主机名，否则绑定到端口将立即发生。要继续进行事件循环，它必须进入轮询阶段，这意味着收到连接并非不可能，从而允许在监听事件之前触发连接事件。</p>
<p>另一个例子就是运行一个函数的构造器，假设该构造函数继承于<code>EventEmitter</code>，并且在构造函数中想调用一个事件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.emit(<span class="string">'event'</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>你不能从构造函数中立即触发事件，因为脚本不会处理到用户为该事件指定回调的位置。 因此，在构造函数本身中，可以使用<code>process.nextTick()</code>来设置回调，以在构造函数完成后触发事件，从而提供预期的结果：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyEmitter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use nextTick to emit the event once a handler is assigned</span></span><br><span class="line">  process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.emit(<span class="string">'event'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(MyEmitter, EventEmitter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">查看原文</a></p>
<h3 id="译者补充"><a href="#译者补充" class="headerlink" title="译者补充"></a>译者补充</h3><p>1、node的核心思想就是异步，异步的实现是基于一个C库–libuv，这个库其实是又一层封装，针对windows和*nix两种系统进行了不同的处理。<br>2、Node的I/O异步<br>    I/O操作主要包括http请求，文件读取等。下图就是整个异步I/O流程：</p>
<p><img src="/img/IOchart.png" alt="io-chart"></p>
<p>这里有三个概念：请求对象，IO观察者，IOCP，线程池。IOCP，是Windows的内核对象，*nix是通过其他方法模拟实现。以下摘自<a href="https://zh.wikipedia.org/wiki/IOCP" target="_blank" rel="noopener">wikipedia</a>:</p>
<blockquote>
<p>输入输出完成端口（Input/Output Completion Port，IOCP）, 是支持多个同时发生的异步I/O操作的应用程序编程接口。</p>
<p>原理：通常的办法是，线程池中的工作线程的数量与CPU内核数量相同，以此来最小化线程切换代价。一个IOCP对象，在操作系统中可关联着多个Socket和（或）文件控制端。 IOCP对象内部有一个先进先出（FIFO）队列，用于存放IOCP所关联的输入输出端的服务请求完成消息。请求输入输出服务的进程不接收IO服务完成通知，而是检查IOCP的消息队列以确定IO请求的状态。 （线程池中的）多个线程负责从IOCP消息队列中取走完成通知并执行数据处理；如果队列中没有消息，那么线程阻塞挂起在该队列。这些现成从而实现了负载均衡。</p>
</blockquote>
<p>3、Node的非I/O异步<br>非I/O的异步操作包括：<code>setTimeout()</code>, <code>setInterval()</code>, <code>process.nextTick()</code>, <code>setImmediate()</code>。</p>
<p>以setTimeout()行为为例：</p>
<p><img src="/img/setTimeout.png" alt="settimeout"></p>
<p>结合译文中那张时间循环阶段图，I/O的异步是在I/O callbacks阶段，<code>setTimeout()</code>和<code>setInterval()</code>是在timer阶段，事件循环中每一次循环会经过那几个阶段，在I/O callbacks阶段中主要是I/O观察者接收通知获取其回调函数及请求结果，然后在此阶段执行回调函数。timer阶段主要是检查由定时器放入的handles是否到达时间，从而执行回调。</p>
<p>对于<code>process.nextTick()</code>和<code>setImmediate()</code>， 前者是idle观察者，后者是check观察者，在每一次循环中，idle观察者先于I/O观察者，I/O观察者先于check观察者。同时，<code>process.nextTick()</code>的回调保存在一个数组中，每次循环会将数组中的回调全部执行完，而<code>setImmediate()</code>的回调保存在链表中，每次循环只执行链表中的一个回调节点。</p>
<p>执行顺序实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">someAsyncOperation</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Assume this takes 95ms to complete</span></span><br><span class="line">  <span class="keyword">const</span> startCallback = <span class="built_in">Date</span>.now();</span><br><span class="line">  fs.readFile(<span class="string">'/koa.js'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now() - startCallback&#125;</span>ms readfile`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timeoutScheduled = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> delay = <span class="built_in">Date</span>.now() - timeoutScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next tick1'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next tick2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">someAsyncOperation(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'next tick'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">next</span> tick1</span><br><span class="line"><span class="keyword">next</span> tick2</span><br><span class="line"><span class="number">2</span>ms <span class="built_in">readfile</span></span><br><span class="line">setImmediate</span><br><span class="line"><span class="keyword">next</span> tick</span><br><span class="line"><span class="number">103</span>ms have passed since I was scheduled</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的十年]]></title>
      <url>/2018/01/31/ten-years/</url>
      <content type="html"><![CDATA[<p>十年前，读高二，那年汶川大地震还有北京奥运会。    </p>
<p>摇晃的地板，天花板上散落的粉尘，我跌跌撞撞地从二楼跑到一楼，跑到空地，呆呆的看着冒烟的教学楼不知道发生了什么，以为是一楼做化学实验发生了爆炸。听到人说是地震，总是后知后觉的我才惊醒过来原来地震是这样。<br>随后，大家的摩托罗拉，诺基亚都纷纷表示没有信号了。     </p>
<p>那天晚上，所有的同学老师在操场睡(坐)(站)了一夜。   </p>
<p>第二天通知放假一个月。   </p>
<p>回到家，家里那个厚重的电视机放在了地上，怕再地震摔了。好几千块的数字电视是父母拮据攒了好久才买下来的。想到家，想到父母的十年，总觉辛酸。那时候的日子，现在想想父母该是怎样熬过来的。家，这个字，太沉重，太温馨，太多回忆。还是收住吧。    </p>
<p>那时候的我，有两位很交心的朋友。每天谈论的是考题，一点八卦，相互鼓励，相互学习，一起在中午十二点钟响冲向食堂，而我们基本上也是最早一批到食堂的。因为我们班在二楼并且离电梯最近，一楼都是实验室。晚上一起打水，从学校这头穿过长长的过道还有地下通道，走到马路对面的女生宿舍。    </p>
<p>晚上关灯后喜欢听我哥送我那个魅族的MP3，到现在都觉得那个MP3挺好看的，貌似还有看视频的功能。庆幸，现在魅族还活着。对于我哥，也有太多的满满温馨美好又辛酸的事情，也很难轻易写出来。    </p>
<p>那时候才刚接触电脑，第一堂电脑课都不知道怎么开机。后面都不记得用什么语言写了个加法乘法函数。那时候网吧好火，就跟同学去了一次，花了两块钱，呆了一个小时，貌似就只干了一件事：注册了个QQ号，好像还看了点东方神起的视频。</p>
<p>10年后，已是工作近四年的人了。这年，等待着是不是也会发生什么不同寻常的事。    </p>
<p>圈子里的人用的手机不是iphone就是iphone还是iphone，当然我是安卓档。而当初那个总是对电脑畏手畏脚的女孩，现在竟然是一名前端程序媛。我做的工作竟也是我十年前完全没有想到的。人生总是处处出乎意料。    </p>
<p>那时候很要好的两个朋友也没什么联系，只是偶尔看到朋友圈的状态和微博。那时候的圈子就是高中，现在的圈子是互联网公司。感觉整个世界的人都被划分到了各种各样的圈子，你的一生会走进几个不同的圈子，每到一个圈子就会遇到一些人一些事，或许只有一两个人能和你成为朋友，其他人对你而言只是过客，而你对他们而言亦是如此。于是，我们在不同的轨迹上走着，或许相交，或许重叠一段，而自始自终都没有任何一个人可以和你一起走。    </p>
<p>现在的我，竟也是一个已婚妇女了。开始体会有家的感觉，过几年，或许就会开始体会身为人母的感觉。    </p>
<p>或许这十年是我最好的十年，不过，我还是期待下个十年，相信下个十年会是更好的十年。</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Koa2]]></title>
      <url>/2018/01/19/koa/</url>
      <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Koa是由Express的原班人马打造的新一代web框架，针对web应用和APIs，旨在成为一个更小，更生动，更强壮的基础框架。借助生成器，Koa可以让你不再受回调的困扰，还大幅度提高了错误处理能力。同时，核心不会集成任何中间件，提供了一套更优雅的方法，使我们写服务端代码更快速更加享受。 </p>
<h2 id="Koa2-Vs-Express"><a href="#Koa2-Vs-Express" class="headerlink" title="Koa2 Vs Express"></a>Koa2 Vs Express</h2><h3 id="设计哲学上的不同"><a href="#设计哲学上的不同" class="headerlink" title="设计哲学上的不同"></a>设计哲学上的不同</h3><p>1、Koa: 为了解决并替换node，Express：增强了node<br>2、Koa使用promise和async来避免回调地狱，使错误处理简单化。暴露它本身的<code>ctx.request</code>和<code>ctx.response</code>对象，而非node的<code>req</code>和<code>res</code>对象。 Express增强了node的<code>req</code>和<code>res</code>对象，添加额外的属性和方法，一级包含了一些其他的”框架”特征，比如路由和模板。但Koa没有这样做。<br>3、Koa可以被视为是node<code>http</code>模块的抽象，但Express是一个针对node的完整的应用框架。</p>
<table>
<thead>
<tr>
<th style="text-align:right">Feature</th>
<th style="text-align:center">Koa</th>
<th style="text-align:center">Express</th>
<th style="text-align:center">Connect</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">Middleware Kernel</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:right">Routing</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">Templating</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">Sending Files</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:right">JSONP</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="Express原理浅析"><a href="#Express原理浅析" class="headerlink" title="Express原理浅析"></a>Express原理浅析</h3><p>我们先只用node的http模块启动一个服务，监听3000端口，以及几个路由：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = require(<span class="string">'http'</span>);</span><br><span class="line">http.createServer((req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">if</span> (req.url === <span class="string">'/'</span>) &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/html"</span> &#125;);</span><br><span class="line">    res.<span class="built_in">end</span>(<span class="string">"Welcome to the homepage!"</span>);</span><br><span class="line">  &#125; <span class="built_in">else</span> <span class="built_in">if</span> (req.url == <span class="string">"/about"</span>) &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/html"</span> &#125;);</span><br><span class="line">    res.<span class="built_in">end</span>(<span class="string">"Welcome to the about page!"</span>);</span><br><span class="line">  &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">    res.<span class="built_in">end</span>(<span class="string">"404 error! File not found."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="built_in">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码的意思是我们启动了一个3000端口的服务，并注册了回调函数，回调函数接收req, res, next三个返回值。当在浏览器输入localhost:3000后，回调函数才会执行。   </p>
<p>用express之后，createServer中入参回调函数就换成了下面一个express的app实例：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">app</span> = express();</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">set</span>('views', path.join(__dirname, 'views'));</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">set</span>('<span class="keyword">view</span> engine', 'hbs');</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>(cookieParser());</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>('/api', checkLoginStatus, apiRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pageRouter = express.Router();</span><br><span class="line">pageRouter.<span class="built_in">get</span>('/page', (req, res, next) =&gt; &#123;res.rendder('page', page)&#125;);</span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>('/page', pageRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理没有URL匹配的中间件</span></span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>((req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">//不处理 map 和 json 格式的数据</span></span><br><span class="line">  <span class="keyword">if</span> (/\.(map|json)$/.<span class="keyword">test</span>(req.url)) &#123;</span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">err</span> = new <span class="keyword">Error</span>(`<span class="variable">$&#123;req</span>.url&#125;,Not Found`);</span><br><span class="line">  <span class="keyword">err</span>.status = 404;</span><br><span class="line">  next(<span class="keyword">err</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有错误处理，这里就是最后一个中间件处理了</span></span><br><span class="line"><span class="keyword">app</span>.<span class="keyword">use</span>((<span class="keyword">err</span>, req, res, next) =&gt; &#123;</span><br><span class="line">  res.status(<span class="keyword">err</span>.status || 500);</span><br><span class="line">  res.render('<span class="keyword">error</span>', &#123;</span><br><span class="line">    layout: false,</span><br><span class="line">    title: '<span class="keyword">Error</span>',</span><br><span class="line">    message: <span class="keyword">err</span>.message,</span><br><span class="line">    <span class="keyword">error</span>: <span class="keyword">err</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="keyword">app</span>).listen(3000);</span><br></pre></td></tr></table></figure>
<p>app使用每一层中间件来处理请求，可以看到通过app.use的方式处理的是应用级别的，比如开始的一些模板cookie等的设置，应用的访问结构（一级访问路径），最后的容错处理等。每一层中间件可以是路由级别的中间件，也可以是个过滤器，拦截器等等。每个请求都会从上到下走一遍，有的中间件是检查权限，有的根据它再获取一些新东西再加到它身上，可能有的让它next()，继续去下一个中间件，有的一拍即合就直接res.render或者res.json，那么这个请求就完成了它的使命，不会再继续往下走了。   </p>
<p>按照使用方法，我们逐条对着源码看看express做了什么。   </p>
<p>首先是<code>var app = express()</code> 这句声明。</p>
<p><strong>主入口express.js</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">require</span>(<span class="string">'./application'</span>);</span><br><span class="line"><span class="keyword">var</span> req = <span class="built_in">require</span>(<span class="string">'./request'</span>);</span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">require</span>(<span class="string">'./response'</span>);</span><br><span class="line"></span><br><span class="line">exports = <span class="built_in">module</span>.exports = createApplication;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义 app 字面量函数</span></span><br><span class="line">  <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    app.handle(req, res, next);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// defines EventEmitter.prototype's descriptors on app if app does not have a descriptor by the same name</span></span><br><span class="line">  mixin(app, EventEmitter.prototype, <span class="literal">false</span>);</span><br><span class="line">  mixin(app, proto, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// expose the prototype that will get set on requests</span></span><br><span class="line">  app.request = <span class="built_in">Object</span>.create(req, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// expose the prototype that will get set on responses</span></span><br><span class="line">  app.response = <span class="built_in">Object</span>.create(res, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(app.response.app.response === app.response); </span><br><span class="line">  app.init();</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>var app = express()</code>这句调用得到的app就是<code>createApplication</code>方法中返回的app。app是个函数，并将node的req, res, next传给了app内部handle方法，赋予handle对于内部对象的控制权。注意这里只是注册handle处理函数，并没有执行。<br>关于以上有一个疑问：<code>app.response</code>和<code>app.request</code>的原型上要暴露app？而app.response.app.response === app.response 执行结果也是true。<br>可以看到，这里app对象里面也暴露了node events模块的方法，除此之外，在这个主文件中还暴露了封装的Route，Router，还有以下几个中间件：   </p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exports</span>.json = bodyParser.json</span><br><span class="line"><span class="keyword">exports</span>.query = require(<span class="string">'./middleware/query'</span>);</span><br><span class="line"><span class="keyword">exports</span>.<span class="keyword">static</span> = require(<span class="string">'serve-static'</span>);</span><br><span class="line"><span class="keyword">exports</span>.urlencoded = bodyParser.urlencoded</span><br></pre></td></tr></table></figure>
<p>然后主入口里面还有这句函数调用：<code>app.init()</code>, 在init中设置了一系列私有变量以及配置项。毕竟在正式开始前，都需要配置一些默认参数。 至此，主入口文件大致搞清楚了。</p>
<p>接下来我们看看启动服务监听端口的声明：<code>app.listen(3000)</code></p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.listen = function listen() &#123;</span><br><span class="line">  var<span class="built_in"> server </span>= http.createServer(this);</span><br><span class="line">  return server.listen.apply(server, arguments);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里其实就是执行了<code>http.createServer(app).listen(3000)</code>。</p>
<p><strong>app.use</strong></p>
<p>重点来了，源码中有大部分是对参数的处理，从最上面的使用代码也可以看到app.use的参数形式多样，总得需要一些判断校验处理，所以省略这些，贴出源码中真正处理的部分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里还有一些处理</span></span><br><span class="line">  <span class="comment">// fns得到所有调用app.use中的函数数组</span></span><br><span class="line">  <span class="keyword">var</span> fns = flatten(slice.call(<span class="built_in">arguments</span>, offset));</span><br><span class="line">  <span class="comment">// setup router</span></span><br><span class="line">  <span class="keyword">this</span>.lazyrouter();</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;</span><br><span class="line"></span><br><span class="line">  fns.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// non-express app</span></span><br><span class="line">    <span class="keyword">if</span> (!fn || !fn.handle || !fn.set) &#123;</span><br><span class="line">      <span class="keyword">return</span> router.use(path, fn);</span><br><span class="line">    &#125;</span><br><span class="line">	 <span class="comment">// 这里处理：如果fn本身有handle或set方法，app就会恢复到出厂设置。</span></span><br><span class="line">	 <span class="comment">// 基本上就是执行app.use(express());才会走到这里</span></span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以<code>app.use(&#39;/&#39;, (req, res) =&gt; {res.send(&#39;hello world&#39;)})</code>调用为例，最终就是执行:<br><code>router.use(&#39;/&#39;, (req, res) =&gt; {res.send(&#39;hello world&#39;)})</code></p>
<p><strong>router.use</strong></p>
<p>同样省去那些校验判断取核心：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, &#123;</span><br><span class="line">  sensitive: <span class="keyword">this</span>.caseSensitive,</span><br><span class="line">  strict: <span class="literal">false</span>,</span><br><span class="line">  end: <span class="literal">false</span></span><br><span class="line">&#125;, fn);</span><br><span class="line"></span><br><span class="line">layer.route = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.stack.push(layer);</span><br></pre></td></tr></table></figure>
<p>调用router.use就会new一个Layer，这个Layer就是一个类，声明如下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Layer</span><span class="params">(path, options, fn)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Layer)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Layer(path, options, fn);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.handle = fn;</span><br><span class="line">  <span class="comment">// 还有一些属性设置  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例子带入之后就是Layer.handle = pageRouter; 这样每一次app.use都会通过这样创建一个层，可以看做是 express 在启动运行的时候，注册好了一个中间件函数栈stack，里面堆叠好了待被调用的中间层，<strong>一旦请求进来，就会执行回调函数，即正式调用app, 也就是<code>app()</code>, app.handle开始执行：</strong></p>
<p><strong>app.handle</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.handle = function handle(req, res, callback) &#123;</span><br><span class="line">  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;</span><br><span class="line">  <span class="comment">// final handler</span></span><br><span class="line">  <span class="keyword">var</span> done = callback || finalhandler(req, res, &#123;</span><br><span class="line">    env: <span class="keyword">this</span>.<span class="keyword">get</span>(<span class="string">'env'</span>),</span><br><span class="line">    onerror: logerror.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">  router.handle(req, res, done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>app.handle又把node服务回调里的三个参数，继续分派给了 express 的核心路由模块。</p>
<p><strong>router.handle</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">proto.handle = <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(req, res, out)</span></span> &#123;</span><br><span class="line">  <span class="built_in">next</span>();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err)</span></span> &#123;</span><br><span class="line">    var layer;</span><br><span class="line">    var route;</span><br><span class="line">    // process_params是处理中间层参数的方法</span><br><span class="line">    self.process_params(layer, paramcalled, req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (route) &#123;</span><br><span class="line">        <span class="keyword">return</span> layer.handle_request(req, res, <span class="built_in">next</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      trim_prefix(layer, layerError, layerPath, <span class="built_in">path</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">trim_prefix</span><span class="params">(layer, layerError, layerPath, path)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (layerError) &#123;</span><br><span class="line">      layer.handle_error(layerError, req, res, <span class="built_in">next</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      layer.handle_request(req, res, <span class="built_in">next</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>按照helloworld的例子，以上最终走向layer.handle_request(req, res, next)。</p>
<p><strong>layer.handle_request</strong></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Layer.prototype.handle_request = <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">(req, res, next)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">this</span>.handle;  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *this.handle就是(req, res) =&gt; &#123;res.send('hello world')&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (fn.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// not a standard request handler</span></span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(req, res, next); <span class="comment">//执行了res.send('hello world')</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    next(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>似乎过程通了，当事件触发时，在express启动时注册的回调函数开始一层一层过滤执行。有点不太清楚为什么要这样通过app.handle =&gt; router.handle =&gt; layer.handle注册回调函数，或许express目的就是做一个完整的应用框架，需要更多的扩展，需要应用级别的层次感，更多的属性以应对各种各样的web应用请求。毕竟大牛们的脑回路是普通人没法比的。如果没有express，我们的node服务估计就是一大串的<code>switch-case</code> 或者<code>if-else</code>，无法想象了！   </p>
<h3 id="Koa2"><a href="#Koa2" class="headerlink" title="Koa2"></a>Koa2</h3><p>先看一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> indent = <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).join(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">`&lt;h3&gt;请求 =&gt; 第一层中间件&lt;/h3&gt;`</span></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  ctx.body += <span class="string">`&lt;h3&gt;响应 &lt;= 第一层中间件&lt;/h3&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body += <span class="string">`&lt;h3&gt;<span class="subst">$&#123;indent(<span class="number">4</span>)&#125;</span>请求 =&gt; 第二层中间件&lt;/h3&gt;`</span></span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">  ctx.body += <span class="string">`&lt;h3&gt;<span class="subst">$&#123;indent(<span class="number">4</span>)&#125;</span>响应 &lt;= 第二层中间件&lt;/h3&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.body += <span class="string">`&lt;p style="color: #f60"&gt;<span class="subst">$&#123;indent(<span class="number">12</span>)&#125;</span>=&gt; Koa 核心 处理业务 &lt;=&lt;/p&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>和Express一样，new一个Koa的实例app,中间件也是通过app.use传递，也是通过app.listen(3000)启动服务监听3000端口，但和Express不同的是，app.listen的实现是这样：<br><code>http.createServer(app.callback()).listen(3000)</code><br>Koa传入的是实例的callback方法，而express传入的是app本身。</p>
<p><strong>app.use</strong></p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span>(<span class="function"><span class="keyword">fn</span>) &#123;</span></span><br><span class="line"><span class="function">  this.middleware.<span class="keyword">push</span><span class="params">(<span class="keyword">fn</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Koa的use很简单，就是把进来的函数压入到一个数组中。再看app.callback()做了什么：</p>
<p><strong>app.callback</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">callback() &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);	</span><br><span class="line">  <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">	 <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">	 <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是compose方法，简单说来就是把那些通过app.use设置的中间件组装成一个递归函数，递归的是Promise方法，而在中间件数组中都是async函数，async本身就是返回Promise，用递归的方式实现Promise的链式执行。    </p>
<p>然后，执行callback()，callback返回了一个local作用域方法handleRequest。这个方法里面通过类方法<code>createContext</code>将req, res合成了ctx，我们会用到的全部属性都在ctx里面，然后将ctx和递归函数fn丢给内部方法<code>this.handleRequest</code>。当我们访问服务时，local的handleRequest(req, res)就触发执行了，并且返回的是<code>this.handleRequest</code>执行后的返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">  <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">  <span class="keyword">return</span> fnMiddleware(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候compose后的链式Promise函数开始执行。到这里，反正我脑子已经不够用了。很抽象，每一行源码都涉及到很深的基础知识，还有对新特性的深入理解。基础不扎实，而且设计又很抽象，确实看起来比较费力。最后放上两张<a href="https://juejin.im/post/5a6dda1d5188257330612d88?utm_source=gold_browser_extension#heading-2" target="_blank" rel="noopener">参考文章-Koa2 还有多久取代 Express</a>里的两张图：    </p>
<p>中间件执行顺序：<br><img src="/img/koa.gif" alt="koa"></p>
<p>请求处理洋葱圈模型：<br><img src="/img/koause.png" alt="koa-use"></p>
<p>后面用起来慢慢体会吧！看Koa2的源码，最大的感受就是Koa2充分运用新的语言特性，自身代码更简洁。整个框架就是4个js文件，结合注释都不到1K行。正如参考文章作者说的，这都是历史的必然。   </p>
<p>对于为什么服务会这样运行，比如，createServer中我们注册的回调函数为什么会在访问浏览器时才触发？这里面需要结合node的事件机制来理解了。我了解不多，<a href="https://juejin.im/post/5a6dda1d5188257330612d88?utm_source=gold_browser_extension#heading-2" target="_blank" rel="noopener">参考文章-Koa2 还有多久取代 Express</a>也有提到，很多还不太理解。到能理解的时候，再做些记录。</p>
<p><strong>TODO：</strong><br>1、搭建Koa2工程化服务<br>2、理解NodeJS事件机制</p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> koa </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript是如何工作的]]></title>
      <url>/2018/01/01/how-js-works/</url>
      <content type="html"><![CDATA[<p>最近在看<a href="https://blog.sessionstack.com/tagged/tutorial" target="_blank" rel="noopener">HOW JAVASCRIPT WORKS</a>一系列文章，做些摘要笔记。</p>
<h2 id="引擎、运行时、调用栈"><a href="#引擎、运行时、调用栈" class="headerlink" title="引擎、运行时、调用栈"></a>引擎、运行时、调用栈</h2><p>广为人知的JS引擎当属V8了，其中主要包含了两个部分：</p>
<ul>
<li>内存堆-内存分配</li>
<li>调用栈-代码执行时的位置即所在的栈帧</li>
</ul>
<p>在下图中，框以内的就是引擎包含的内容，框以外的是浏览器提供的遵循ES标准的Web API、事件轮询、回调队列。我相信很多同学可能跟我一样，开始学习JS时会觉得DOM操作，回调队列什么的都是引擎实现的。现在仔细想想，ES标准为什么会存在浏览器差异，这就是原因了吧。   </p>
<p><img src="http://p0.qhimg.com/t01a740c0b9b73dbfd6.png"></p>
<p>JS是单线程语言，换句话说就是它只有一个调用栈。调用栈就是一种记录程序执行处于哪个位置的数据结构。栈是一种先进后出、后进先出的数据结构。<br>看这样一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printSquare</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> s = multiply(x, x);</span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line">printSquare(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<p>JS<strong>运行</strong>顺序：<br><code>printSquare(5) =&gt; multiply(x, y) =&gt; console.log(s)</code><br>调用栈：<br><img src="https://cdn-images-1.medium.com/max/1600/1*Yp1KOt_UJ47HChmS9y7KXw.png"><br>这样是不是很直观易懂了！</p>
<p>我们常常会碰到这样的错误：<br><img src="https://cdn-images-1.medium.com/max/1600/1*e0nEd59RPKz9coyY8FX-uw.png"><br>栈溢出了！一般说来通常发生在循环调用的情况，比如以下一段代码：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    foo();</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>所以在使用递归时，正确的条件终止就很重要了～    </p>
<h2 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h2><p>V8引擎之所以这么流行，有个重要原因是Node.js也是基于V8。    </p>
<p>V8设计之初就是为了提高JS在浏览器中的执行速度，所以V8直接将JS代码转换成更有效率的机器代码而非使用解释器的方式。V8实现了一个名为JIT(Just-In-Time)的编译器，它将JS代码编译成机器代码。而且这里区别于其他引擎最主要的一点是：V8不生成字节码或任何中间代码，这样就无需解释器。  </p>
<p>引擎中有几个线程分工协作，分别完成加载代码执行、编辑优化、垃圾回收、记录执行时间等。对于它是如何具体优化编译可以具体查看<a href="https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e" target="_blank" rel="noopener">原文</a>。几个主要概念记录如下：   </p>
<ul>
<li>内联：就跟webpack打包把import的具体一段样式代码插到import的位置类似，通过内联的方式，将调用的函数替换到调用位置。</li>
<li>隐藏类：具体例子在原文中可以看到。隐藏类是在运行时创建，用来查找对象位置。我的理解是，代码执行时，依照执行顺序，每执行一句，就创建一个隐藏类，这个隐藏类又基于前一句代码执行时创建的隐藏类。这样，<strong>代码的执行顺序也会对隐藏类顺序产生影响</strong>。而且它会不断叠加记录上一个隐藏类的offset。所以当一个对象执行完后，到最后那个隐藏类上就记录了之前每一句代码的隐藏类offset。</li>
<li>内联缓存：对于重复的调用内联代码，那么这段调用也会有相同的隐藏类。V8先查找该对象的隐藏类，确定offset，在对同一个隐藏类进行了两次成功的调用后，V8就会省去隐藏类查找，只将offset添加到该对象指针本身上就行了。这样，对于对该方法的重复调用，V8会直接通过offset跳转到对应的内存地址。</li>
</ul>
<p>对于隐藏类，也不确定理解是否正确。补充原文中的图文加强一下：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*spJ8v7GWivxZZzTAzqVPtA.png"><br>所以，针对以上，在写代码时，就有下面几点可以注意了：<br>1、对象属性的顺序：始终以相同的顺序实例化对象属性，以便可以共享隐藏类和随后优化的代码。<br>2、动态属性：在实例化后向对象添加属性会强制修改隐藏类，减慢为之前的隐藏类优化了的方法。所以应该在构造函数中指定对象的所有属性。<br>3、方法：重复执行相同方法的代码将比只执行一次的代码（由于内联缓存）运行得快。<br>4、数组：避免键不是增量数字的稀疏数组。元素不全的稀疏数组是一个哈希表，而访问这种数组中的元素更昂贵。另外，尽量避免预分配大数组。最好随着发展而增长。最后，不要删除数组中的元素。它会让键变得稀疏。<br>5、标记值：V8用32位表示对象和数字。它用一位来判断是对象（flag = 1）还是整数（flag=0）（这个整数称为SMI（SMall Integer，小整数），因为它是31位）。然后，如果一个数值大于31位，V8将会对数字装箱，将其转化为 double，并创建一个新对象将该数字放在里面。所以要尽可能使用31位有符号数字，从而避免昂贵的转换为JS对象的装箱操作。</p>
<h2 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h2><p>相信很多都知道<code>setTimeout(function, 0)</code>了，就是运用了事件轮询和回调队列的机制，达到让该function在特定的步骤去执行的目的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">cb1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'cb1'</span>);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Bye'</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="https://cdn-images-1.medium.com/max/1600/1*TozSrkk92l8ho6d8JxqF_w.gif"></p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[记一次 wechaty running on docker 之旅]]></title>
      <url>/2017/11/28/docker/</url>
      <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>当被告知要结合wechaty做一个自动发消息的微信机器人时，我真的有点懵。看了一下wechaty的文档，推荐通过docker运行。我当时的内心表情就是what? 什么鬼？前端的东西已经让我应接不暇，这些偏后台运维的就一点都不懂了。但能怎么办呢，还带着一个实习生一起做，老大安排的任务，跪着也得完成啊！<br>于是乎，咬着牙硬着头皮开始看各种文档，在本地把脚本运行起来，暴露http接口给我们的管理后台用。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>1、docker for mac    </p>
<p>官网下载docker客户端就行<a href="https://store.docker.com/editions/community/docker-ce-desktop-mac" target="_blank" rel="noopener">下载地址</a><br>安装后，直接可以在Mac终端docker info，可以看到docker信息，就成功了。</p>
<p>2、npm和node</p>
<p>为了本地开发方便，不多说了，前端必备环境。</p>
<h2 id="运行例子"><a href="#运行例子" class="headerlink" title="运行例子"></a>运行例子</h2><p>1、在本地创建一个文件夹myWechaty<br>2、<code>npm init</code>创建package.json<br>3、<code>npm install --save qrcode-termial</code><br>4、创建mybot.js <a href="https://github.com/Chatie/wechaty" target="_blank" rel="noopener">官方6行代码</a><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Wechaty &#125; = <span class="built_in">require</span>(<span class="string">'wechaty'</span>) <span class="comment">// import &#123; Wechaty &#125; from 'wechaty'</span></span><br><span class="line"></span><br><span class="line">Wechaty.instance() <span class="comment">// Singleton</span></span><br><span class="line">.on(<span class="string">'scan'</span>, <span class="function">(<span class="params">url, code</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Scan QR Code to login: <span class="subst">$&#123;code&#125;</span>\n<span class="subst">$&#123;url&#125;</span>`</span>))</span><br><span class="line">.on(<span class="string">'login'</span>,       <span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`User <span class="subst">$&#123;user&#125;</span> logined`</span>))</span><br><span class="line">.on(<span class="string">'message'</span>,  <span class="function"><span class="params">message</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;message&#125;</span>`</span>))</span><br><span class="line">.start()</span><br></pre></td></tr></table></figure></p>
<p>5、修改一下scan事件，引入<code>qrcode-terminal</code>，方便直接在控制台显示二维码<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Wechaty &#125; = <span class="built_in">require</span>(<span class="string">'wechaty'</span>) <span class="comment">// import &#123; Wechaty &#125; from 'wechaty'</span></span><br><span class="line"><span class="keyword">const</span> QrcodeTerminal = <span class="built_in">require</span>(<span class="string">'qrcode-terminal'</span>);</span><br><span class="line"></span><br><span class="line">Wechaty.instance() <span class="comment">// Singleton</span></span><br><span class="line">.on(<span class="string">'scan'</span>, <span class="function">(<span class="params">url, code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Scan QR Code to login: <span class="subst">$&#123;code&#125;</span>\n<span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="regexp">/201|200/</span>).test(<span class="built_in">String</span>(code))) &#123;</span><br><span class="line">    <span class="keyword">const</span> loginUrl = url.replace(<span class="regexp">/\/qrcode\//</span>, <span class="string">'/l/'</span>)</span><br><span class="line">    QrcodeTerminal.generate(loginUrl)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.on(<span class="string">'login'</span>,        <span class="function"><span class="params">user</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`User <span class="subst">$&#123;user&#125;</span> logined`</span>))</span><br><span class="line">.on(<span class="string">'message'</span>,   <span class="function"><span class="params">message</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;message&#125;</span>`</span>))</span><br><span class="line">.start()</span><br></pre></td></tr></table></figure></p>
<p>6、在终端进入myWechaty文件夹，并运行<code>docker run -ti --name=mybot --rm --volume=&quot;$(pwd)&quot;:/bot zixia/wechaty mybot.js</code>   </p>
<ul>
<li>命令中的 <code>zixia/wechaty</code>是wechaty包装好的docker镜像，mybot.js是运行于这个镜像之上的一段脚本，这个镜像运行依赖的环境可以通过<a href="https://hub.docker.com/r/zixia/wechaty/~/dockerfile/" target="_blank" rel="noopener">docker hub 上wechaty的dockerfile</a>看到:<br> 依赖了一系列命令，有熟知bash, curl, git, sudo, vim等等，还下载了nodejs，还运行了npm install，也就是说，这个镜像依赖的环境也是我们需要的，我们无需再获取。</li>
<li>关于docker run 命令解释：<br>  a、-ti 可命令交互<br>  b、–name=mybot 创建容器的名称是mybot<br>  c、–rm  退出命令后，自动删除容器<br>  d、–volume=”$(pwd)”:/bot  在镜像外层目录上挂载一个bot文件夹，里面存放的是myWechaty里的内容。</li>
<li>新开终端，<code>docker ps</code> 列出当前所有容器，可以看到有我们的mybot</li>
</ul>
<p>7、终端显示二维码，用微信扫码即可。这样，就可以在终端查看到微信消息了。<br>了解了以上之后，我们就可以在<code>mybot.js</code>中开发我们需要的功能了。</p>
<h2 id="mybot-js中暴露接口"><a href="#mybot-js中暴露接口" class="headerlink" title="mybot.js中暴露接口"></a>mybot.js中暴露接口</h2><p><strong>难以入手的问题</strong><br>在写接口之前，我在想怎么在本地访问呢？现在的环境node已经有了，wechaty本身也有服务，我又该怎么做呢？这个问题困扰了我很久，总之，还是因为对docker环境不了解。<br>几番周折查找，原来就在docker run命令里面设置一个参数就能解决。<br><strong><code>-p 8888:8888</code></strong> ： 将虚拟机器（即mybot容器）的地址端口映射到我们本地端口。<br>在myWechaty mybot.js中，引入：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const express</span> = require(<span class="string">'express'</span>);</span><br><span class="line"><span class="attribute">const app</span> = express();</span><br><span class="line"><span class="attribute">const bodyParser</span> = require(<span class="string">'body-parser'</span>);</span><br></pre></td></tr></table></figure></p>
<p>再对body解析：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">app</span><span class="selector-class">.use</span>(bodyParser.json(&#123;<span class="attribute">limit</span>: <span class="string">'20mb'</span>&#125;));<span class="comment">//设置前端post提交最大内容</span></span><br><span class="line"><span class="selector-tag">app</span><span class="selector-class">.use</span>(bodyParser.urlencoded(&#123;<span class="attribute">limit</span>: <span class="string">'20mb'</span>, <span class="attribute">extended</span>: false&#125;));</span><br><span class="line"><span class="selector-tag">app</span><span class="selector-class">.use</span>(bodyParser.text());</span><br></pre></td></tr></table></figure></p>
<p>再添加一段监听日志代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8888</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Example app listening on port 3000!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>终端：<br>1、<code>npm install --save express body-parser</code><br>2、<code>docker run -ti --name=mybot --rm --volume=&quot;$(pwd)&quot;:/bot -p 8888:8888 zixia/wechaty mybot.js</code>   </p>
<p>看到监听日志打出来了，也有微信消息。 在浏览器中访问<code>localhost:8888</code>, Hello World!<br>到这里了，暴露接口不就是顺手拈来的事情了么！    </p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>到此，基本上开发就是这样了，跟平常做node开发一样。最后，就是看是否需要将开发的内容打包成镜像发布，还是直接就这样运行就行了。打包镜像的话，就是注意Dockerfile的配置，进行docker build。   </p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ios的坑，你填过多少]]></title>
      <url>/2017/10/13/ioshole/</url>
      <content type="html"><![CDATA[<h3 id="关于user-select"><a href="#关于user-select" class="headerlink" title="关于user-select"></a>关于user-select</h3><p><strong>现象：</strong><br>    input输入框无法focus，输入时只能输入一个字符，后面再输入就好像无法聚焦一样，再重新点击聚焦，又可以输入第二个字符，而且显示在第一个字符的前面。<br><strong>解决：</strong><br>    发现这个问题是在一个react项目中，尝试过用通过不断触发focus，但也无疾而终。发现css的样式里面有个user-select设置为none, 改成initial就好了。<br>    最终通用css：对不是input和textarea以及只读的input和textarea才设置user-select为none。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-pseudo">:not(input)</span><span class="selector-pseudo">:not(textarea)</span>, <span class="selector-tag">input</span><span class="selector-attr">[readonly]</span>, <span class="selector-tag">textarea</span><span class="selector-attr">[readonly]</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-touch-callout</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-khtml-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">  <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">  <span class="attribute">user-select</span>: none;</span><br><span class="line">  <span class="attribute">outline-style</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/10819565/user-selectnone-causes-input-field-to-be-inaccessible-on-safari" target="_blank" rel="noopener">参考答案</a>     </p>
<h3 id="input光标隐藏"><a href="#input光标隐藏" class="headerlink" title="input光标隐藏"></a>input光标隐藏</h3><p><strong>现象：</strong><br>    底层的input聚焦后，触发其他条件显示一个弹层时，光标会显示在弹层上面。<br><strong>解决：</strong></p>
<ul>
<li>想法1： 触发弹层显示后，让input失去焦点。  用的react中的 this.refs.input.blur() 貌似没起作用。</li>
<li>想法2： 触发弹层后，通过如下css隐藏光标。   </li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: -<span class="number">999em</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/driftyco/ionic/issues/26" target="_blank" rel="noopener">参考答案</a></p>
<h3 id="window-scrollTo"><a href="#window-scrollTo" class="headerlink" title="window.scrollTo"></a>window.scrollTo</h3><p><strong>现象：</strong><br>    ios中嵌入H5页面，页面为长列表，点击单个列表进入详情后，再回退。页面卡顿，没有展示内容，点击稍微滑动一下页面，内容才展示出来。在componentDidMount中用window.scrollTo(0, 0)并没有效果。<br><strong>解决：</strong>   </p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/11845371/window-scrollto-is-not-working-in-mobile-phones" target="_blank" rel="noopener">参考答案</a></p>
<h3 id="position-fixed问题"><a href="#position-fixed问题" class="headerlink" title="position: fixed问题"></a>position: fixed问题</h3><p><strong>现象：</strong><br>    在iOS上，当点击input出现键盘输入时，fixed的元素会失效，iOS会认为时absolute的。<br><strong>解决：</strong><br>    当然，在不会出现键盘输入情况的页面时，应该是可以放心大胆的用fixed做布局的。如果有键盘输入，可以通过将除了fixed的其他全部内容放到一个绝对定位的容器中。示例代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,user-scalable=no"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        html,body&#123;</span></span><br><span class="line"><span class="undefined">            width: 100%;</span></span><br><span class="line"><span class="undefined">            height: 100%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line"><span class="undefined">            position: relative;</span></span><br><span class="line"><span class="undefined">            height: 100%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.content-wrap</span>&#123;</span></span><br><span class="line"><span class="undefined">            position: absolute;</span></span><br><span class="line"><span class="undefined">            top: 0;</span></span><br><span class="line"><span class="undefined">            left: 0;</span></span><br><span class="line"><span class="undefined">            right: 0;</span></span><br><span class="line"><span class="undefined">            bottom: 2rem;</span></span><br><span class="line"><span class="undefined">            min-height: 100%;</span></span><br><span class="line"><span class="undefined">            -webkit-touch-scrolling: touch;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.dec-button-wrap</span>&#123;</span></span><br><span class="line"><span class="undefined">            position: fixed;</span></span><br><span class="line"><span class="undefined">            z-index: 999;</span></span><br><span class="line"><span class="undefined">            bottom: 0;</span></span><br><span class="line"><span class="undefined">            left: 0;</span></span><br><span class="line"><span class="undefined">            width: 100%;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.modal-msk</span>&#123;</span></span><br><span class="line"><span class="undefined">            position: fixed;</span></span><br><span class="line"><span class="undefined">            top: 0;</span></span><br><span class="line"><span class="undefined">            left: 0;</span></span><br><span class="line"><span class="undefined">            right: 0;</span></span><br><span class="line"><span class="undefined">            bottom: 0;</span></span><br><span class="line"><span class="undefined">            width: 100%;</span></span><br><span class="line"><span class="undefined">            height: 100%;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(0, 0, 0, <span class="selector-class">.5</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"decoration"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-wrap"</span>&gt;</span></span><br><span class="line">        // other all content</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"button-wrap"</span>&gt;</span></span><br><span class="line">        // fixed button at bottom</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-msk"</span>&gt;</span></span><br><span class="line">        // fixed modal</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另外还可以通过将内容包裹在一个具有CSS3滑动属性的div中。通过变换translateY属性实现滚动。参考插件<a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">iscroll</a> 以及 <a href="https://github.com/AlloyTeam/AlloyTouch" target="_blank" rel="noopener">AlloyTouch</a></p>
<h3 id="iOS-微信问题"><a href="#iOS-微信问题" class="headerlink" title="iOS 微信问题"></a>iOS 微信问题</h3><p><strong>现象：</strong><br>    1、在微信iOS上，页面加载就白屏。<br>    2、分享设置似乎没成功？首页进去分享没有问题，后面的页面分享后没有那些配置信息。<br><strong>解决：</strong><br>    1、微信里面的这种白屏，不显示之类的问题，多半就是JS报错了，但不好调试。所以，首先微信页面用微信开发者工具先过一遍，看有没有报错。当项目需要适配自己公司的APP，适配微信的时候，再将适配部分的代码多理理，理清楚。说不定就发现有些有漏洞的地方了。<br>    2、分享问题，深觉是微信最难调试之首，不能更多了。相对耗费时间精力，而且有的时候安卓和IOS表现还不一样。不过，大部分问题通过debug还是可以看出来，微信开发者文档里面也有<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="noopener">错误信息问题的原因</a>。<br>    迄今为止，最奇葩的问题是 针对 <strong>单页应用</strong>，如果只在进入页面时，wx.config, ready就调用一次，安卓分享invalid signature，IOS正常。于是看文档，原来可能是地址的原因，所以在每个路由页面都config ready 了一次，安卓OK了！结果IOS又有问题。但debug时，并没有报错。怀疑还是地址的原因，然后复制了IOS路由的地址，发现所有路由地址都是首次进去的那个地址。<br>    这样。。针对IOS，就config一次，安卓就每个页面都调一次。或者缓存一下首页地址，判断是安卓就更改地址，重新调用signature，并config。但其实还有点问题，IOS分享的时候 有的页面分享OK，有的还是显示首页的地址。感觉已经尽力了，精疲力竭了。时间不等人，这个先暂时放一放，毕竟不影响业务。</p>
<p>参考资料：<br><a href="https://blog.csdn.net/github_37519401/article/details/78406159" target="_blank" rel="noopener">csdn</a><br><a href="https://github.com/vuejs/vue-router/issues/481" target="_blank" rel="noopener">vue issue</a></p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ios </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[秋，好像来了]]></title>
      <url>/2017/08/27/autumn/</url>
      <content type="html"><![CDATA[<p>之前问过同学，北京什么时候开始冷。她说，夏天完了就秒进冬天，没有秋天。我知道，这只是一种形容。最近几天，我似乎感觉到了些许秋高气爽，昼夜温差更大了，晚上下班后竟然还有点凉飕飕的。正午艳阳高照，仍然是夏天的气氛，不过如果躲在大树下却一点都不闷。我喜欢这种什么都刚刚好的天气。   </p>
<p>工作上感觉确实比在成都累多了，工作刚一个月，但好像做了很多事情。早上9点半，到晚上平均9点，可能这在北京的互联网公司已经算好的了，但比起之前，还是有点适应不过来。而且周末随时都有一天的加班，平时已经挺累的，周末实在不想看任何和工作相关的事情。所以，我一直是保持着能不加就不加的态度，有什么问题我都会在平日上班时间解决完。这一个月还一次没加过。但组里貌似就我一人这样，是我不对么？是我搞特殊么？这周，有两次加班（貌似是小组集体的），我都没去，不是我想有什么特殊，是我觉得没有必要，至少我负责的那块没有必要。老大没说我，但我能感觉到似乎有些不满。或许吧，哪怕是做一些配合我也应该去一下吧。   </p>
<p>今天下雨了，越发觉得秋天来了。一直下，一直下，住在三环边上，很吵，但今早清净了不少，大概也是由于周末配上下雨天吧。天空就像一个巨大的蓄水池，乌云就似那个洗澡的喷头，冲洗着布满灰尘的大树，房顶，街道。桥上的车子就是一把把刷子，流水线似的刷着车道。工作群里有人说，外面挺冷的。对，是他们去加班的。不知道他们中午一起吃饭的时候，会不会有人说，那谁怎么没来。   </p>
<p>或许，我真的不应该选择这里，应该去个更独立陌生的环境。来北京的目的是什么，在这个相对熟悉的环境我能找到我想要的么？一切似乎变得更遥远。   </p>
<p>秋，好像来了，因为她总是容易让人伤感。   </p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初来乍到]]></title>
      <url>/2017/08/12/%E5%88%9D%E6%9D%A5%E4%B9%8D%E5%88%B0/</url>
      <content type="html"><![CDATA[<p>思前想后，终于还是来了。</p>
<p>想想，第一次来北京是旅游。和大多数人一样，觉得应该到祖国中心看看，看看那个毛主席宣布“中华人民共和国在今天成立了”到天安门广场，看看被八国联军无耻扫荡的圆明园，看看绵延不绝永不倒的万里长城，还有无数学子向往的清华北大。于是，和室友在大三期末考完就坐了整整一天的火车来了，为此还逃了那个学期最后一堂行教课。在海淀黄庄附近的一个小酒店住了下来，现在看来一晚上很便宜，当然空间也很小。穷游嘛，玩了5天左右总共才花了一千多点。回想起来，可以用以下几个词概括：白天晒，晚上凉，酱太多，地铁方便。对，差不多就这些。夏天，空气也还好，感觉每天还蓝天白云。</p>
<p>第二次是14年毕业，公司一个月培训，也是夏天。还是义无反顾的晒，公司地址在国家会议中心。出去就是鸟巢水立方。附近没什么人气，也看不到什么餐厅，只有一个商场，吃饭就要逛商场。还跟同届的小伙伴吃了北京烤鸭，反正至今不想再吃第二次。唯一觉得合口味的就是疙瘩汤了。那时候就想，幸好选择在成都的分公司。</p>
<p>这一次，17年夏天，工作刚刚三年。这三年，在成都，我和男朋友结了婚，买了房，开了车，照理说就该过上平稳的小康生活了。但我俩总是不安分，总感觉生活太平常了，应该要有点什么来刺激一下，打破我们的舒适圈。很不幸，我俩又是程序员，成都的机会太少了，还是应该去北京打拼打拼，感受一下。于是，就这样，开始投北京的简历了，很快，陆陆续续地我就约了满满一周的面试。没想到hr的处理速度是这样快。是的，从这里就能感受到成都和北京的不同了。</p>
<p>正如之前那些前辈说的，我俩在北京能很快找到合适的工作。我们不信，但结果正如他们所说，老公还开玩笑地说竟然体验到了offer收割机的感觉。所以在犹豫着想到北京来闯一闯的童鞋，如果你的能力还OK，心里总有点不甘心的话，就放心大胆的来吧。</p>
<p>写到这里的时候，我已经工作两周了，在北京差不多已有一月有余。夏天的空气不算差，有的时候还能见到在成都都难得一见的纯粹的蓝天白云，还有点像是在泸沽湖那种天空。前两天早上中度污染，可一出门就感觉到了比成都更纯的雾霾，明显有种刺鼻的感觉。空气状况比较极端，就跟这里其他东西一样，比如外卖很便宜，因为满减很给力，而进店吃一碗面就是30起。这里早晚也很凉快，小区里的老大爷老奶奶都会出来乘凉。这是一座朝气蓬勃而又悠然自得的城市。大与小，老与少，很分明。</p>
<p>对于城市的体会目前就这些，再说说工作氛围吧。确实和成都差别很大，因为这里大部分公司都会包晚饭，所以不用操心回家做饭，也就不急着要准点下班了。而且晚餐不重样，至少比自己做的好吃一点。所以，吃完后，再写会代码，差不多7点多，八点陆续也就回去了，也并没有觉得强度很大。而且，最重要的一点是，公司比那个没有家的感觉的出租屋更舒服，回去似乎也没什么特别的事，就这样，下班的时候就到了八九点了。这是我在成都怎么都无法想象的。而且是每天晚上如此。</p>
<p>是的，迄今为止，并没有那么讨厌北京。</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> life </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端面试]]></title>
      <url>/2017/06/28/interview/</url>
      <content type="html"><![CDATA[<p>好吧，正式做了两年的前端er，现在轮到我找工作了。其实也没打算要离开，因为一直觉得自己还像一个嗷嗷待哺的雏鸟，离开了这个温暖的窝就无法生存。无奈公司的业务调整，我们几个人都离开了，我也不得不扑哧着翅膀摇摇晃晃的飞出去。<br>工作期间没动力的时候就出去面试了下，主要是看看自己处于什么水平吧，发现基础确实不太扎实，也尽自己努力沉下心来系统的看书学习。面试肯定也要有所准备嘛，大半年的看书，确实对js有了更深入的理解，有些概念也慢慢明白。<br>现在离职两周了，面了好些了，有几个感觉挺有希望的，也谈了薪资，不知道为什么最终没有offer。最欣慰的是，有一家公司第一面觉得我基础挺扎实，嘻嘻～很高兴得到这样的肯定，但是后面要求做个项目笔试题，有点不想做吧，加上又有另外一个公司的笔试项目题，就中断了。<br>现在想想，我还是不够努力吧，没有珍惜任何一次机会。说不定就有个offer了呢！汲取教训吧，以后不要再这样了。言归正传，记录下最近没回答好的面试题：</p>
<p>1、讲讲输入完网址按下回车，到看到网页这个过程中发生了什么</p>
<ul>
<li>域名解析</li>
<li>发起TCP的3次握手：<br>第一次：建立请求时，客户端向服务端发送一个序列包，syn=j。<br>第二次：服务端响应客户端的syn包，发送确认包的信息ack=j+1，自己再发送一个syn包是k。<br>第三次：客户端确认收到服务端的syn和ack，并向服务器发送ack包（ack=k+1）。发送后，服务端和客户端就建立起了TCP连接。</li>
<li>建立TCP连接后发起http请求</li>
<li>服务器端响应http请求，浏览器得到html代码</li>
<li>浏览器解析html代码，并请求html代码中的资源   </li>
<li>浏览器对页面进行渲染</li>
</ul>
<p>2、实现屏幕居中的正方形<br>解决难点：</p>
<ul>
<li>正方形<br>padding-top, margin-top是百分比时，是以父级元素的宽度为标准。</li>
<li>垂直水平居中<br>flex，transform</li>
</ul>
<p>代码实现一：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.square</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码实现二：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.square</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(-50%, -50%, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</p>
<ul>
<li>图片懒加载，滚动到相应位置才加载图片。</li>
<li>图片预加载，如果为幻灯片、相册等，将当前展示图片的前一张和后一张优先下载。</li>
<li>使用CSSsprite，SVGsprite，Iconfont、Base64等技术，如果图片为css图片的话。</li>
<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>
<li>CDN缓存图片</li>
</ul>
<p>4、requireJS模块加载原理<br>依次加载require的模块，然后监听文档的onreadystatechange事件（若不支持就监听script的onload事件），判断所有模块加载成功，执行require的callback， 如果只带一个参数且不是数组，就是加载成功后return 模块。</p>
<p>这其中有两个问题：</p>
<ul>
<li>如何解决循环依赖，造成加载死循环：<br>在模块加载依赖的时候，先检查模块依赖中是否存在正在注册的模块，如果存在的话，则先将模块依赖数量减一。通过这种方法用来解决循环依赖的问题。</li>
<li>如何解决重复加载：<br>将已经加载的模块放到一个对象中，在加载依赖时，先检查这个对象中是否存在，如果存在直接返回这个模块。</li>
</ul>
<p>5、vue和react的区别</p>
<ul>
<li>最直观的区别就是Vue比React体量更小。</li>
<li>JSX vs Templates: react中所有的组件渲染都依靠JSX，偏逻辑。Vue更相对传统，基于 HTML 的模板更偏向视图形式。</li>
<li>规模上来讲：react社区比vue更繁荣，因为vue中的路由管理都是由官方同步更新，react是交由社区维护。</li>
</ul>
<p>6、用一个函数实现add(1,2)=3, add(1)(2) = 3…..<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">arguments</span>.length)&#123;</span><br><span class="line">            <span class="keyword">var</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;args.length; i++)&#123;</span><br><span class="line">                s += args[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> otherArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>);</span><br><span class="line">            args.push(otherArgs);</span><br><span class="line">            <span class="comment">//Array.prototype.push.apply(args, arguments);</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;，</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)());</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)());</span><br></pre></td></tr></table></figure></p>
<p>7、找出n以内的质数，尽量快。<br>一个是用sqrt，另外就是用筛选法，一次筛出2、3、5、7、…的倍数，直到i * i &gt; n。剩下的就是质数了。</p>
<p>8、问为什么要雇用你，你有什么价值。<br>其实挺讨厌这样的问题的，我怎么知道你看中我的啥。事后想想，我觉得我可以这样说：我觉得目前为止，自己就是一颗螺丝钉，虽不起眼，但在整个机器运作中，也发挥了自己的力量。至于为什么不是其他螺丝钉，我想通过一轮一轮的面试，你们会觉得我是一个稳定的靠谱的螺丝钉吧。</p>
<p>9、块级元素和行内元素的区别<br>行内是指 <code>display: inline</code>的元素 ，这类元素设置margin时，只有左右会生效。padding也会生效。常用的span、em、strong都是行内元素。<br>块级是指元素出了内容区以为的空间都会被占满。div  p  ul都是块级元素。</p>
<p>10、position的定位<br>主要是relative属性和static属性，因为这两个中， static是默认的，通常没太在意。relative，通常是搭配子元素需要绝对定位的时候用，也没怎么去了解它本身的定义。<br><strong>必须记住</strong>：<code>static</code>的元素是代表不能被positioned的，即没有<code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code>这些属性，而<code>position</code>不是<code>static</code>的情况都是可以被positioned，均有偏移属性。<br>那么为什么通常会将<code>relative</code>和<code>absolute</code>搭配使用，是因为<code>absolute</code>的元素是相对于<strong>最近的一个positioned的父级元素</strong>，这样说来其实父级元素只要不是<code>static</code>定位的都可以进行子元素相对父元素的绝对定位。如果绝对定位的元素没有“positioned”的父元素，那么它是相对于文档的 body 元素，并且它会随着页面滚动而滚动。<br>详细解读可查看<a href="http://zh.learnlayout.com/position.html" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>11、shouldComponentUpdate和setState有什么关联<br>setState之后，会走shouldComponentUpdate这个阶段，因为这里默认返回是true，所以都会进行re-render，如果在shouldComponentUpdate中，根据nextState和this.state或者nextProps和this.props进行比较，确认是否需要更新，返回false的情况下就不会进行re-render。</p>
<p>12、对ES6中class的理解<br>Class就是一个对象原型写法的语法糖，更清晰，更面向对象，更接近传统语言的写法。<br>ES5定义类的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>ES6定义：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES5中的构造函数就类似class中的<code>constructor</code>，原型上的方法就是类中声明的函数。class声明的类和ES5中构造函数使用一样。<br>另外用Class声明的类不会存在变量提升。<a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">完整解释</a>。</p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> interview </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[非阻塞脚本]]></title>
      <url>/2017/05/11/script/</url>
      <content type="html"><![CDATA[<h4 id="什么是阻塞？"><a href="#什么是阻塞？" class="headerlink" title="什么是阻塞？"></a>什么是阻塞？</h4><p>我的理解：当外部引入的js文件或者css文件一直没有下载成功，导致页面DOM没有渲染出来时，就形成了页面阻塞。这显然对用户体验很差。</p>
<h4 id="怎么才能不阻塞？"><a href="#怎么才能不阻塞？" class="headerlink" title="怎么才能不阻塞？"></a>怎么才能不阻塞？</h4><p>从阻塞的形成，我们就知道造成阻塞可能有以下原因：</p>
<ul>
<li>js，css文件较多，较大。下载时间长。</li>
<li>js 文件在DOM文档结构之前，js一直在下载或执行中。  </li>
</ul>
<p>所以针对以上可能的原因，我们发现根本在于JS加载执行时间和DOM渲染时间的冲突。那么，只要保证JS加载执行在DOM加载后，是不是就能保证是无阻塞脚本了呢。从技术的角度讲，就是在window的load事件触发之后再下载文件。<br>对于CSS，如果CSS比较少，可以采取内联的方式放在HTML<style></style>里面，可以看到，webpack在打包时就是引入相关的CSS内联到页面中。<br>对于JS，有以下几种方式：   </p>
<ol>
<li><code>&lt;script&gt;</code>标签放在<code>&lt;body&gt;</code>里面，但是DOM结构之后，这样就能保证DOM加载完再加载JS文件，或者script标签里的JS代码。</li>
<li><p>HTML4<code>script</code>标签有一个defer属性，意思是延迟。jquery.min.js会异步加载，不影响DOM的加载，只是会等到DOM加载完成后再执行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.min.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：HTML5新增了一个属性async，它和defer的区别在于，在异步加载JS之后会自动执行，执行的过程可能会阻塞DOM。</p>
</li>
<li><p>动态脚本插入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">        script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">        <span class="keyword">if</span> (script.readyState) &#123; <span class="comment">//IE</span></span><br><span class="line">            script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (script.readyState === <span class="string">'loaded'</span> || script.readyState === <span class="string">"complete"</span>) &#123;</span><br><span class="line">                    script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">                    callback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        script.src = url;</span><br><span class="line">        <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    loadScript(<span class="string">"https://www.google-analytics.com/analytics.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//js逻辑</span></span><br><span class="line">        alert(<span class="string">'loaded'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>IE 对这两个 readyState 值所表示的最终状态并不一致，有时<code>&lt;script&gt;</code>元素会得到“loaded”却从不出现“complete”，但另外 一些情况下出现“complete”而用不到“loaded”。最安全的办法就是在 readystatechange 事件中检查这两种状 态，<strong>并且当其中一种状态出现时，删除 readystatechange 事件句柄(保证事件不会被处理两次)</strong>。<br>通过这种方法，无论在何处启动下载，文件的下载和运行都不会阻塞其他页面处理过程。你甚至可以将这些代码放在 <head><meta name="generator" content="Hexo 3.8.0">部分而不会对其余部分的页面代码造成影响(除了用于下载文件的 HTTP 连接)。同时，这种方法可以跨域加载，所以比较常用。</head></p>
<ol>
<li>XMLHttpRequest动态脚本注入<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">'get'</span>, <span class="string">'file.js'</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">                script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">                script.text = xhr.responseText;</span><br><span class="line">                <span class="built_in">console</span>.log(script.text);</span><br><span class="line">                <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>执行之后如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2165404-530389b2a8671340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>但这种无法跨域下载，所以运用较少。</p>
<h4 id="建议的无阻塞模式"><a href="#建议的无阻塞模式" class="headerlink" title="建议的无阻塞模式"></a>建议的无阻塞模式</h4><p>通过以上的分析，权衡利弊之后，应该是通过loadScript方式，会更好一些。将页面初始化所需的JS单独加载之后，再通过动态加载的方式加载其他不需要立即执行的JS代码。 例如:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"loader.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> //初始化页面时需要的JS代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  loadScript(<span class="string">"the-rest.js"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; </span></span><br><span class="line"><span class="undefined">      Application.init();</span></span><br><span class="line"><span class="undefined">  &#125;); </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>另外，再结合第一种将<code>script</code>放在<code>&lt;/body&gt;</code>之前，DOM之后。这样当第二部分 JavaScript 文件完成下载，所有应用程序所必须的 DOM 已经创建好了，并做好被访问的准备，避免使用额外的事件处理(例如 window.onload) 来得知页面是否已经准备好了。<br>对于这种方式，有完整的开源实现，只需要引用就行了：</p>
<ul>
<li>雅虎的<a href="http://github.com/rgrove/lazyload/" target="_blank" rel="noopener">lazyLoad</a></li>
<li><a href="http://labjs.com/" target="_blank" rel="noopener">LABjs</a></li>
</ul>
<h4 id="更多参考"><a href="#更多参考" class="headerlink" title="更多参考"></a>更多参考</h4><p><a href="https://segmentfault.com/q/1010000000640869" target="_blank" rel="noopener">defer和async的区别</a><br><a href="http://ued.ctrip.com/blog/script-defer-and-async.html#" target="_blank" rel="noopener">script的defer和async</a><br><a href="https://juejin.im/post/587f4afb61ff4b00651b3c18" target="_blank" rel="noopener">什么阻塞了DOM</a></p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你不知道的JS-引擎、作用域、编译器]]></title>
      <url>/2017/01/22/youdontkownjs1/</url>
      <content type="html"><![CDATA[<p>最近在开始看《你不知道的JS》，深入讲解JS内部的原理。做些笔记，温故知新。</p>
<h3 id="引擎、作用域、编译器的关系"><a href="#引擎、作用域、编译器的关系" class="headerlink" title="引擎、作用域、编译器的关系"></a>引擎、作用域、编译器的关系</h3><p>在最开始学习编程的时候，大家都会想我们这些代码是怎么转换成计算机可以执行的指令？这一转换很复杂，细想之，也很神奇。就我能所了解的，大概是这样的步骤：</p>
<ul>
<li>1、程序代码经过编译器的词法分析，语义分析，形成语义结构树，并分配逻辑内存。</li>
<li>2、转换成汇编指令，分配物理内存。</li>
<li>3、汇编指令转换为电路逻辑，具体形成计算机执行的二进制指令，通过0、1来控制电路。   </li>
</ul>
<p>我想，大概是这样吧。其实这三步对应的正是我们大学学习计算机的三门课程：编译原理、汇编、数字逻辑。这里面的逻辑地址和物理地址其实我也忘了，我猜大概是这样。因为没有一个老师会讲从c或者Java代码到cpu执行究竟是怎样的过程，每一门课程都是单独的，只会讲到那门课对应的内容。扯远了，JavaScript的编译器做的事情和其他语言编译器做的事情是一致的，都是进行词法分析和语法分析。在编译的过程中，会和作用域配合，分配内存。   </p>
<p>JavaScript是一门运行时语言，编译时间很少，引擎在执行过程中会不断查找作用域。查找有两种方式：RHS和LHS。   </p>
<ul>
<li>LHS：赋值查找，比如var a = 2; 事实上，引擎会分两步执行这条语句。第一步var a，引擎会在作用域中查找变量a，如果存在，就执行第二步”=2”，即把2赋值给a。如果没有找到，就在作用域中创建一个变量a，再执行第二步。</li>
<li>RHS : 取得源值，比如console.log(a); 其中a就是RHS查询，这里要获得a的值。</li>
</ul>
<p>可以说，编译器和作用域是引擎的基础，编译器对代码进行优化，合理组织作用域，可以让引擎更方便的查询作用域。</p>
<h3 id="为什么有RHS和LHS查询"><a href="#为什么有RHS和LHS查询" class="headerlink" title="为什么有RHS和LHS查询"></a>为什么有RHS和LHS查询</h3><h4 id="非严格模式"><a href="#非严格模式" class="headerlink" title="非严格模式"></a>非严格模式</h4><p><img src="/img/you-dont-kown-js-1-01.png" alt="you-dont-kown-js-1-01"></p>
<p>在foo里面，执行a+b，对b进行RHS查询时，没有找到b，出现ReferenceError。将b =2；放在前面，虽然没有var b；但这时对b是LHS查询，查询不到会自动在全局作用域中创建变量b，并赋值。而后自然能RHS查询取得b的值。</p>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p><img src="/img/you-dont-kown-js-1-02.png" alt="you-dont-kown-js-1-02"><br>当LHS查询不到b时，并不会自动创建该变量。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="作用域气泡"><a href="#作用域气泡" class="headerlink" title="作用域气泡"></a>作用域气泡</h4><p><img src="/img/you-dont-kown-js-1-03.png" alt="you-dont-kown-js-1-03">   </p>
<h4 id="查询规则"><a href="#查询规则" class="headerlink" title="查询规则"></a>查询规则</h4><p>   在当前作用域查找，如果查找不到，就向上（向外层）作用域查找，直到首次找到为止。（找到后就不再查找，注意变量隐藏，替换的问题）</p>
]]></content>
      
        <categories>
            
            <category> FE </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
